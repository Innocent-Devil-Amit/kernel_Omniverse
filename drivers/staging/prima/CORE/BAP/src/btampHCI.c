/*
 * Copyright (c) 2012-2013 The Linux Foundation. All rights reserved.
 *
 * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
 *
 *
 * Permission to use, copy, modify, and/or distribute this software for
 * any purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * This file was originally distributed by Qualcomm Atheros, Inc.
 * under proprietary terms before Copyright ownership was assigned
 * to the Linux Foundation.
 */

/**
  * \file btampHCI.c
  *
  * \brief Structures, functions & definitions for
  * working with 802.11 Frames
  *
  *

  *
  *
  * This file was automatically generated by 'framesc'
  * Fri Feb 27 17:29:19 2009 from the following file(s):
  *
  * btampHCI.frms
  *
  * PLEASE DON'T EDIT THIS FILE BY HAND!
  *
  *
  */

#include <memory.h> /* For memcpy */
#include <stddef.h> /* For offsetof */

#define _vsnprintf vsnprintf

#include "vos_api.h"
#include "btampHCI.h"

#if defined ( _MSC_VER )
#   pragma warning (disable: 4244)
#   pragma warning (disable: 4505)
#   pragma warning (disable: 4702)
#   pragma warning (disable: 4996) /* ... was declared deprecated */
#endif /* Microsoft C/C++ */

/*Length of the value field expected in a TLV of type Connected Channel in an 
 AMP Assoc*/
#define WLAN_BAP_PAL_AMP_ASSOC_CONN_CH_TLV_MIN_LEN    3

/*Length of the value field expected in a TLV of type Preferred Channel in an 
 AMP Assoc*/
#define WLAN_BAP_PAL_AMP_ASSOC_PREF_CH_TLV_MIN_LEN    3

/*Length of the value field expected in a TLV of type MAC Address*/
#define WLAN_BAP_PAL_MAC_ADDR_TLV_LEN                 6

/*Length of the value field expected in a TLV of type Capabilities*/
#define WLAN_BAP_PAL_CAPABILITIES_TLV_LEN             4

/*Length of the value field expected in a TLV of type Version*/
#define WLAN_BAP_PAL_VERSION_TLV_LEN             5

/*Length of the value field expected in a TLV of type Accept Phy Link*/
#define WLAN_BAP_PAL_ACC_PHY_LINK_TLV_MIN_LEN               3

/*Length of the value field expected in a TLV of type Accept Log Link*/
#define WLAN_BAP_PAL_ACC_LOG_LINK_TLV_LEN                  37

/*Length of the value field expected in a TLV of type Create Log Link*/
#define WLAN_BAP_PAL_CREATE_LOG_LINK_TLV_LEN               37

/*Length of the value field expected in a TLV of type Create Phy Link*/
#define WLAN_BAP_PAL_CREATE_PHY_LINK_TLV_MIN_LEN            3

/*Length of the value field expected in a TLV of type Disconnect Log Link*/
#define WLAN_BAP_PAL_DISC_LOG_LINK_TLV_LEN                  2

/*Length of the value field expected in a TLV of type Disconnect Phy Link*/
#define WLAN_BAP_PAL_DISC_PHY_LINK_TLV_LEN                  2

/*Length of the value field expected in a TLV of type Flow Spec Modify*/
#define WLAN_BAP_PAL_FLOW_SPEC_MOD_TLV_LEN                 34

/*Length of the value field expected in a TLV of type Flush*/
#define WLAN_BAP_PAL_FLUSH_TLV_LEN                          2 

/*Length of the value field expected in a TLV of type enhanced Flush*/
#define WLAN_BAP_PAL_ENHANCED_FLUSH_TLV_LEN                 3 

/*Length of the value field expected in a TLV of type Cancel Log Link*/
#define WLAN_BAP_PAL_CANCEL_LOG_LINK_TLV_LEN                2

/*Length of the value field expected in a TLV of type Read Best Effort Flush 
 Timeout*/
#define WLAN_BAP_PAL_READ_BE_FLUSH_TIMEOUT_TLV_LEN          2

/*Length of the value field expected in a TLV of type Read Failed Contact 
 Counter*/
#define WLAN_BAP_PAL_READ_FAILED_CONTACT_CNT_TLV_LEN        2

/*Length of the value field expected in a TLV of type Link Quality*/
#define WLAN_BAP_PAL_READ_LINK_QUALITY_TLV_LEN              2

/*Length of the value field expected in a TLV of type Read Link Supervision
  Timeout*/
#define WLAN_BAP_PAL_READ_LINK_SVISISON_TIMEOUT_TLV_LEN     2

/*Length of the value field expected in a TLV of type Read Local AMP Assoc*/
#define WLAN_BAP_PAL_READ_LOCAL_AMP_ASSOC_TLV_LEN           5

/*Length of the value field expected in a TLV of type Read RSSI*/
#define WLAN_BAP_PAL_READ_RSSI_TLV_LEN                      2

/*Length of the value field expected in a TLV of type Reset Failed Contact 
 Counter*/
#define WLAN_BAP_PAL_RESET_FAILED_CONTACT_CNT_TLV_LEN       2

/*Length of the value field expected in a TLV of type Set Event Mask*/
#define WLAN_BAP_PAL_SET_EVENT_MASK_TLV_LEN                 8

/*Length of the value field expected in a TLV of type Set Event Mask2*/
#define WLAN_BAP_PAL_SET_EVENT_MASK2_TLV_LEN                8

/*Length of the value field expected in a TLV of type Set SHort Range Mode*/
#define WLAN_BAP_PAL_SET_SHORT_RANGE_MODE_TLV_LEN           2

/*Length of the value field expected in a TLV of type Write Best Effort Flush 
  Timeout*/
#define WLAN_BAP_PAL_WRITE_BE_FLUSH_TIMEOUT_TLV_LEN         6

/*Length of the value field expected in a TLV of type Write Connection Accept 
  Timeout*/
#define WLAN_BAP_PAL_WRITE_CON_ACC_TIMEOUT_TLV_LEN          2

/*Length of the value field expected in a TLV of type Write Flow Control Mode*/
#define WLAN_BAP_PAL_WRITE_FLOW_CTRL_MODE_TLV_LEN           1

/*Length of the value field expected in a TLV of type Write Link Supervision
  Timeout*/
#define WLAN_BAP_PAL_WRITE_LINK_SVISION_TIMEOUT_TLV_LEN     4

/*Length of the value field expected in a TLV of type Write Location Data*/
#define WLAN_BAP_PAL_WRITE_LOCATION_DATA_CMD_TLV_LEN        5

/*Length of the value field expected in a TLV of type Write LL Acc Timeout*/
#define WLAN_BAP_PAL_WRITE_LOG_LINK_ACC_TIMEOUT_TLV_LEN     2

/*Length of the value field expected in a TLV of type Write Loopback Mode*/
#define WLAN_BAP_PAL_WRITE_LOOOPBACK_MODE_TLV_LEN           1

/*Length of the value field expected in a TLV of type Write Remote AMP Assoc*/
#define WLAN_BAP_PAL_WRITE_REMOTE_AMP_ASSOC_MIN_TLV_LEN     5 

/* As per AMP specification */
/* Regulatory Extension Identifier for channel list */
#define WLAN_BAP_PAL_REG_EXTN_ID_VAL                        201

/* Regulatory Class for channel list */
#define WLAN_BAP_PAL_REG_CLASS_VAL                          254

/* Coverage ClASS for channel list */
#define WLAN_BAP_PAL_COVERAGE_CLASS_VAL                     0


/* LOGGING and VALIDITY_CHECKING control */
//#define WLAN_BAPHCI_ENABLE_VALIDITY_CHECKING
//#define WLAN_BAPHCI_ENABLE_LOGGING

typedef unsigned char tFRAMES_BOOL;
typedef void (*pfnGeneric_t)(void);


typedef struct sFFDefn {
    v_U8_t  size;
    size_t       offset;
    v_U16_t sig;
    pfnGeneric_t pfn;
    const char  *name;
} tFFDefn;

typedef struct sIEDefn {
    v_U8_t   eid;
    v_U16_t  minSize;
    v_U16_t  maxSize;
    size_t        offset;
    size_t        presenceOffset;
    size_t        countOffset;
    v_U16_t  arraybound;
    unsigned char oui[5];
    unsigned char noui;
    v_U16_t  sig;
    pfnGeneric_t  pfn;
    const char   *name;
    tFRAMES_BOOL  fMandatory;
} tIEDefn;

#if !defined(countof)
#define countof(x) ( sizeof( (x) ) / sizeof( (x)[0] ) )
#endif

#if ! defined(BTAMP_MEMCPY)
#   define BTAMP_MEMCPY(ctx, dst, src, len) \
        vos_mem_copy( (dst), (src), (len) )        \

#endif

#if ! defined(BTAMP_MEMCMP)
#   define BTAMP_MEMCMP(ctx, lhs, rhs, len) \
        memcmp( (lhs), (rhs), (len) )        \

#endif

#ifndef BTAMP_HAVE_LOG_SEVERITIES
#   define FRLOG_OFF ( 0 )
#   define FRLOGP    ( 1 )
#   define FRLOGE    ( 2 )
#   define FRLOGW    ( 3 )
#   define FRLOG1    ( 4 )
#   define FRLOG2    ( 5 )
#   define FRLOG3    ( 6 )
#   define FRLOG4    ( 7 )
#endif

#define FRFL(x) x

#ifdef BTAMP_ENABLE_LOGGING

#ifndef BTAMP_HAVE_LOG_MACROS

#include <stdio.h>
#include <stdarg.h>

#ifndef BTAMP_LOG_GATE
#   define BTAMP_LOG_GATE FRLOGW
#endif // BTAMP_LOG_GATE

#ifdef WIN32

#if defined ( _CONSOLE ) || defined ( _WINDOWS ) || defined ( _DLL ) || defined ( _LIB )
#include <windows.h>
#define DBGPRINT OutputDebugStringA
#else  /* Not User mode */
#define DBGPRINT DbgPrint
#endif /* User mode */



static void framesLog(void * pCtx, int nSev,
                      const char *lpszFormat, ...)
{
    va_list val;
    char buffer[1024];
    (void)pCtx;
    if ( nSev <= BTAMP_LOG_GATE )
    {
        va_start(val, lpszFormat);
        _vsnprintf(buffer, 1024, lpszFormat, val);
        va_end(val);
        DBGPRINT(buffer);
    }
}
static void framesDump(void * pCtx, int nSev, v_U8_t *pBuf, int nBuf)
{
    char buffer[35];
    int i, offset;
    pCtx;
    offset = 0;
    if ( nSev > BTAMP_LOG_GATE ) return;
    for (i = 0; i < nBuf/8; ++i)
    {
        _snprintf(buffer, 35, "%08x: %02x %02x %02x %02x %02x %02x %02x %02x\n", offset, *pBuf, *(pBuf + 1), *(pBuf + 2), *(pBuf + 3), *(pBuf + 4), *(pBuf + 5), *(pBuf + 6), *(pBuf + 7));
        pBuf += 8; offset += 8;
        DBGPRINT(buffer);
    }
    _snprintf(buffer, 35, "%08x: ", offset);
    DBGPRINT(buffer);
    for (i = 0; i < nBuf % 8; ++i)
    {
        _snprintf(buffer, 35, "%02x ", *pBuf);
        ++pBuf;
        DBGPRINT(buffer);
    }
    DBGPRINT("\n");
}

#elif defined OS_X /* Not WIN32 */
static void framesLog(void * pCtx, int nSev,
                      const char *lpszFormat, ...)
{// To fill in when needed using IOLog

}

static void framesDump(void * pCtx, int nSev, v_U8_t *pBuf, int nBuf)
{
}

#elif defined LINUX

static void framesLog(void * pCtx, int nSev,
                      const char *lpszFormat, ...)
{
    va_list marker;
    (void)pCtx;
    if ( nSev <= BTAMP_LOG_GATE )
    {
        va_start( marker, lpszFormat );
        vprintf(lpszFormat, marker);
        va_end( marker );
    }
}

static void framesDump(void * pCtx, int nSev, v_U8_t *pBuf, int nBuf)
{
    char buffer[35];
    int i, offset;
    (void)pCtx;
    offset = 0;
    if ( nSev > BTAMP_LOG_GATE ) return;
    for (i = 0; i < nBuf/8; ++i)
    {
        printf("%08x: %02x %02x %02x %02x %02x %02x %02x %02x\n", offset, *pBuf, *(pBuf + 1), *(pBuf + 2), *(pBuf + 3), *(pBuf + 4), *(pBuf + 5), *(pBuf + 6), *(pBuf + 7));
        pBuf += 8; offset += 8;
    }
    printf("%08x: ", offset);
    for (i = 0; i < nBuf % 8; ++i)
    {
        printf("%02x ", *pBuf);
        ++pBuf;
    }
    printf("\n");
}

#endif /* WIN32 */

#define FRAMES_LOG0(ctx, sev, fmt) \
     framesLog((ctx), (sev), (fmt));
#define FRAMES_LOG1(ctx, sev, fmt, p1) \
     framesLog((ctx), (sev), (fmt), (p1));
#define FRAMES_LOG2(ctx, sev, fmt, p1, p2) \
     framesLog((ctx), (sev), (fmt), (p1), (p2));
#define FRAMES_LOG3(ctx, sev, fmt, p1, p2, p3) \
     framesLog((ctx), (sev), (fmt), (p1), (p2), (p3));
#define FRAMES_DUMP(ctx, sev, p, n) \
     framesDump((ctx), (sev), (p), (n));
#ifndef FRAMES_SEV_FOR_FRAME
#   define FRAMES_SEV_FOR_FRAME(ctx, sig) FRLOG3
#endif

#endif /* End BTAMP_HAVE_LOG_MACROS */

#else  // ! BTAMP_ENABLE_LOGGING
#   define FRAMES_LOG0(ctx, sev, fmt)
#   define FRAMES_LOG1(ctx, sev, fmt, p1)
#   define FRAMES_LOG2(ctx, sev, fmt, p1, p2)
#   define FRAMES_LOG3(ctx, sev, fmt, p1, p2, p3)
#   define FRAMES_DUMP(ctx, sev, p, n)
#   ifndef FRAMES_SEV_FOR_FRAME
#       define FRAMES_SEV_FOR_FRAME(ctx, sig) FRLOG3
#   endif
#endif // BTAMP_ENABLE_LOGGING

#if defined( BTAMP_ENABLE_DBG_BREAK ) && defined ( WIN32 )
#   define FRAMES_DBG_BREAK() { _asm int 3 }
#else
#   define FRAMES_DBG_BREAK()
#endif

#if ! defined(BTAMP_PARAMETER_CHECK2)
#   if defined (BTAMP_HAVE_WIN32_API)

#       define BTAMP_PARAMETER_CHECK2(pSrc, pBuf, nBuf, pnConsumed) do { \
        if (!pSrc || IsBadReadPtr(pSrc, 4)) return BTAMP_BAD_INPUT_BUFFER; \
        if (!pBuf || IsBadWritePtr(pBuf, nBuf)) return BTAMP_BAD_OUTPUT_BUFFER; \
        if (!nBuf) return BTAMP_BAD_OUTPUT_BUFFER;                      \
        if (IsBadWritePtr(pnConsumed, 4)) return BTAMP_BAD_OUTPUT_BUFFER; \
    } while (0)

#   else

#       define BTAMP_PARAMETER_CHECK2(pSrc, pBuf, nBuf, pnConsumed) do { \
        if (!pSrc) return BTAMP_BAD_INPUT_BUFFER;                       \
        if (!pBuf) return BTAMP_BAD_OUTPUT_BUFFER;                      \
        if (!nBuf) return BTAMP_BAD_OUTPUT_BUFFER;                      \
        if (!pnConsumed) return BTAMP_BAD_OUTPUT_BUFFER;                \
    } while (0)
#   endif
#endif

static void framesntohs(void *    pCtx,
                        v_U16_t *pOut,
                        v_U8_t  *pIn,
                        tFRAMES_BOOL  fMsb)
{
    (void)pCtx;
#   if defined ( BTAMP_LITTLE_ENDIAN_HOST )
    if ( !fMsb )
    {
        BTAMP_MEMCPY(pCtx, ( v_U16_t* )pOut, pIn, 2);
    }
    else
    {
        *pOut = ( v_U16_t )( *pIn << 8 ) | *( pIn + 1 );
    }
#   else
    if ( !fMsb )
    {
        *pOut = ( v_U16_t )( *pIn | ( *( pIn + 1 ) << 8 ) );
    }
    else
    {
        BTAMP_MEMCPY(pCtx, ( v_U16_t* )pOut, pIn, 2);
    }
#   endif
}

static void framesntohl(void *    pCtx,
                        v_U32_t *pOut,
                        v_U8_t  *pIn,
                        tFRAMES_BOOL  fMsb)
{
    (void)pCtx;
#   if defined ( BTAMP_LITTLE_ENDIAN_HOST )
    if ( !fMsb )
    {
        *pOut = * ( v_U32_t* )pIn;
    }
    else
    {
        *pOut = ( v_U32_t )( *pIn         << 24 ) |
                ( *( pIn + 1 ) << 16 ) |
                ( *( pIn + 2 ) <<  8 ) |
                ( *( pIn + 3 ) );
    }
#   else
    if ( !fMsb )
    {
        *pOut = ( v_U32_t )( *( pIn + 3 ) << 24 ) |
                                ( *( pIn + 2 ) << 16 ) |
                                ( *( pIn + 1 ) <<  8 ) |
                                ( *( pIn ) );
    }
    else
    {
        *pOut = * ( v_U32_t* )pIn;
    }
#   endif
}

static void frameshtons(void *    pCtx
,                        v_U8_t  *pOut,
                        v_U16_t  pIn,
                        tFRAMES_BOOL  fMsb)
{
    (void)pCtx;
#   if defined ( BTAMP_LITTLE_ENDIAN_HOST )
    if ( !fMsb )
    {
        BTAMP_MEMCPY(pCtx, pOut, &pIn, 2);
    }
    else
    {
        *pOut         = ( pIn & 0xff00 ) >> 8;
        *( pOut + 1 ) = pIn & 0xff;
    }
#   else
    if ( !fMsb )
    {
        *pOut         = pIn & 0xff;
        *( pOut + 1 ) = ( pIn & 0xff00 ) >> 8;
    }
    else
    {
        BTAMP_MEMCPY(pCtx, pOut, &pIn, 2);
    }
#   endif
}

static void frameshtonl(void *    pCtx,
                        v_U8_t  *pOut,
                        v_U32_t  pIn,
                        tFRAMES_BOOL  fMsb)
{
    (void)pCtx;
#   if defined ( BTAMP_LITTLE_ENDIAN_HOST )
    if ( !fMsb )
    {
        BTAMP_MEMCPY(pCtx, pOut, &pIn, 4);
    }
    else
    {
        *pOut         = ( pIn & 0xff000000 ) >> 24;
        *( pOut + 1 ) = ( pIn & 0x00ff0000 ) >> 16;
        *( pOut + 2 ) = ( pIn & 0x0000ff00 ) >>  8;
        *( pOut + 3 ) = ( pIn & 0x000000ff );
    }
#   else
    if ( !fMsb )
    {
        *( pOut     ) = ( pIn & 0x000000ff );
        *( pOut + 1 ) = ( pIn & 0x0000ff00 ) >>  8;
        *( pOut + 2 ) = ( pIn & 0x00ff0000 ) >> 16;
        *( pOut + 3 ) = ( pIn & 0xff000000 ) >> 24;
    }
    else
    {
        BTAMP_MEMCPY(pCtx, pOut, &pIn, 4);
    }
#   endif
}

typedef struct sTLVDefn {
    v_U32_t   id;
    v_U32_t   pec;
    v_U32_t   minSize;
    v_U32_t   maxSize;
    size_t         offset;
    size_t         presenceOffset;
    v_U16_t   sig;
    pfnGeneric_t   pfn;
    const char *   name;
    v_U8_t    fMandatory;
} tTLVDefn;

static tTLVDefn* FindTLVDefn( void *    pCtx,
                              v_U8_t  *pBuf,
                              v_U32_t  nBuf,
                              tTLVDefn      TLVs[ ] )
{
    tTLVDefn    *pTlv;
    v_U32_t      sType, sLen;
    v_U32_t pec;
    v_U16_t id;
 
    sType = 1;
    sLen  = 2;
 
    (void)pCtx;
 
    if (sType == 2) 
        framesntohs( pCtx, &id, pBuf, 2 );
    else {
        id = *pBuf;
    }

    pTlv = &( TLVs[ 0 ] );
    while ( 0xffff != pTlv->id )
    {
        if ( id == pTlv->id )
        {
            if ( 0 == pTlv->pec ) return pTlv;

            if( nBuf > 5 )
            {
                pec =  ( ( * ( pBuf + 4 ) ) << 16 ) |
                       ( ( * ( pBuf + 5 ) ) <<  8 ) |
                           * ( pBuf + 6 );
                if ( pec == pTlv->pec )
                {
                    return pTlv;
                }
            }
        }

        ++pTlv;
    }

    return NULL;
}

static v_U32_t UnpackTlvCore( void *   pCtx,
                                   v_U8_t *pBuf,
                                   v_U32_t nBuf,
                                   tTLVDefn     TLVs[ ],
                                   v_U8_t *pFrm,
                                   size_t       nFrm );
static v_U32_t PackTlvCore(void * pCtx,
                                v_U8_t *pSrc,
                                v_U8_t *pBuf,
                                v_U32_t  nBuf,
                                v_U32_t *pnConsumed,
                                tTLVDefn  TLVs[],
                                v_U32_t *pidx);
static v_U32_t GetPackedSizeTlvCore(void * pCtx,
                                         v_U8_t *pFrm,
                                         v_U32_t *pnNeeded,
                                         tTLVDefn  TLVs[]);

v_U32_t btampUnpackTlvAMP_Assoc_Connected_Channel(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVAMP_Assoc_Connected_Channel *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_AMP_ASSOC_CONN_CH_TLV_MIN_LEN > tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR, "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/


    pDst->present = 1;
    BTAMP_MEMCPY(pCtx, pDst->country, pBuf, 3);
    pBuf += 3;
    tlvlen -= (v_U8_t)3;
    if ( ! tlvlen )
    {
        pDst->num_triplets = 0U;
        return 0U;
    }
    else
    {
        /* Maximum of 5 triplets allowed, based on size of triplets definition */
        if (tlvlen / 3 > 5)
        {
            tlvlen = 15;
        }
        pDst->num_triplets = (v_U8_t)( tlvlen / 3 );

        BTAMP_MEMCPY(pCtx, pDst->triplets, pBuf, ( tlvlen ) );
        pBuf += ( tlvlen );
        tlvlen -= ( tlvlen );
    }
    (void)pCtx;
    return status;
} /* End btampUnpackTlvAMP_Assoc_Connected_Channel. */

typedef v_U32_t (*pfnUnpackTlvAMP_Assoc_Connected_Channel_t)(void *, v_U8_t*, v_U16_t, tBtampTLVAMP_Assoc_Connected_Channel*);

#define SigUnpackTlvAMP_Assoc_Connected_Channel ( 0x0001 )


v_U32_t btampUnpackTlvAMP_Assoc_MAC_Addr(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVAMP_Assoc_MAC_Addr *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_MAC_ADDR_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING    
      /*Log invalid len*/
      VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,"Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    BTAMP_MEMCPY(pCtx, pDst->mac_addr, pBuf, 6);
    pBuf += 6;
    tlvlen -= (v_U8_t)6;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvAMP_Assoc_MAC_Addr. */

typedef v_U32_t (*pfnUnpackTlvAMP_Assoc_MAC_Addr_t)(void *, v_U8_t*, v_U16_t, tBtampTLVAMP_Assoc_MAC_Addr*);

#define SigUnpackTlvAMP_Assoc_MAC_Addr ( 0x0002 )


v_U32_t btampUnpackTlvAMP_Assoc_PAL_Capabilities(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVAMP_Assoc_PAL_Capabilities *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_CAPABILITIES_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING    
      /*Log invalid len*/
      VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,"Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    framesntohl(pCtx, &pDst->pal_capabilities, pBuf, 0);
    pBuf += 4;
    tlvlen -= (v_U8_t)4;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvAMP_Assoc_PAL_Capabilities. */

typedef v_U32_t (*pfnUnpackTlvAMP_Assoc_PAL_Capabilities_t)(void *, v_U8_t*, v_U16_t, tBtampTLVAMP_Assoc_PAL_Capabilities*);

#define SigUnpackTlvAMP_Assoc_PAL_Capabilities ( 0x0003 )


v_U32_t btampUnpackTlvAMP_Assoc_PAL_Version(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVAMP_Assoc_PAL_Version *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */


     /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_VERSION_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING    
      /*Log invalid len*/
      VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,"Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    pDst->pal_version = *pBuf;
    pBuf += 1;  
    tlvlen -= (v_U8_t)1;
    framesntohs(pCtx, &pDst->pal_CompanyID, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    framesntohs(pCtx, &pDst->pal_subversion, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvAMP_Assoc_PAL_Version. */

typedef v_U32_t (*pfnUnpackTlvAMP_Assoc_PAL_Version_t)(void *, v_U8_t*, v_U16_t, tBtampTLVAMP_Assoc_PAL_Version*);

#define SigUnpackTlvAMP_Assoc_PAL_Version ( 0x0004 )


v_U32_t btampUnpackTlvAMP_Assoc_Preferred_Channel_List(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVAMP_Assoc_Preferred_Channel_List *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_AMP_ASSOC_PREF_CH_TLV_MIN_LEN > tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING    
      /*Log invalid len*/
      VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,"Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    /* Contry String - 3 bytes */
    BTAMP_MEMCPY(pCtx, pDst->country, pBuf, 3);
    pBuf += 3;
    tlvlen -= (v_U8_t)3;

    if ( ! tlvlen )
    {
        pDst->num_triplets = 0U;
        return status;
    }
    else
    {
        /* Maximum of 5 triplets allowed, based on size of triplets definition */
        if (tlvlen > 15)
        {
            tlvlen = 15;
        }
        pDst->num_triplets = (v_U8_t)( tlvlen / 3 );

        BTAMP_MEMCPY(pCtx, pDst->triplets, pBuf, ( tlvlen ) );
        pBuf += ( tlvlen );
        tlvlen -= ( tlvlen );
    }
    return status;
} /* End btampUnpackTlvAMP_Assoc_Preferred_Channel_List. */

typedef v_U32_t (*pfnUnpackTlvAMP_Assoc_Preferred_Channel_List_t)(void *, v_U8_t*, v_U16_t, tBtampTLVAMP_Assoc_Preferred_Channel_List*);

#define SigUnpackTlvAMP_Assoc_Preferred_Channel_List ( 0x0005 )


v_U32_t btampUnpackTlvFlow_Spec(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVFlow_Spec *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_FLOW_SPEC_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING 
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    pDst->flow_spec_id = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    pDst->service_type = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    framesntohs(pCtx, &pDst->max_sdu, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    framesntohl(pCtx, &pDst->sdu_inter_arrival, pBuf, 0);
    pBuf += 4;
    tlvlen -= (v_U8_t)4;
    framesntohl(pCtx, &pDst->access_latency, pBuf, 0);
    pBuf += 4;
    tlvlen -= (v_U8_t)4;
    framesntohl(pCtx, &pDst->flush_timeout, pBuf, 0);
    pBuf += 4;
    tlvlen -= (v_U8_t)4;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvFlow_Spec. */

typedef v_U32_t (*pfnUnpackTlvFlow_Spec_t)(void *, v_U8_t*, v_U16_t, tBtampTLVFlow_Spec*);

#define SigUnpackTlvFlow_Spec ( 0x0006 )


v_U32_t btampUnpackTlvHCI_Accept_Logical_Link_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Accept_Logical_Link_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
#ifdef WLAN_BAPHCI_ENABLE_VALIDITY_CHECKING
    if ( WLAN_BAP_PAL_ACC_LOG_LINK_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
//      return BTAMP_INVALID_TLV_LENGTH; 
    }
#endif

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/

    pDst->present = 1;
    pDst->phy_link_handle = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    BTAMP_MEMCPY(pCtx, pDst->tx_flow_spec, pBuf, 18);
    pBuf += 18;
    tlvlen -= (v_U8_t)18;
    BTAMP_MEMCPY(pCtx, pDst->rx_flow_spec, pBuf, 18);
    pBuf += 18;
    tlvlen -= (v_U8_t)18;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Accept_Logical_Link_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Accept_Logical_Link_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Accept_Logical_Link_Cmd*);

#define SigUnpackTlvHCI_Accept_Logical_Link_Cmd ( 0x0007 )


v_U32_t btampUnpackTlvHCI_Accept_Physical_Link_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Accept_Physical_Link_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_ACC_PHY_LINK_TLV_MIN_LEN > tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    pDst->phy_link_handle = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    pDst->key_length = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    pDst->key_type = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    if (pDst->key_length > 32){
        pDst->present = 0;
        return BTAMP_SKIPPED_BAD_IE;
    }

    BTAMP_MEMCPY(pCtx, pDst->key_material, pBuf, ( pDst->key_length ) );
    pBuf += ( pDst->key_length );
    tlvlen -= ( pDst->key_length );
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Accept_Physical_Link_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Accept_Physical_Link_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Accept_Physical_Link_Cmd*);

#define SigUnpackTlvHCI_Accept_Physical_Link_Cmd ( 0x0008 )


v_U32_t btampUnpackTlvHCI_Channel_Selected_Event(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Channel_Selected_Event *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    pDst->phy_link_handle = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Channel_Selected_Event. */

typedef v_U32_t (*pfnUnpackTlvHCI_Channel_Selected_Event_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Channel_Selected_Event*);

#define SigUnpackTlvHCI_Channel_Selected_Event ( 0x0009 )


v_U32_t btampUnpackTlvHCI_Command_Complete_Event(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Command_Complete_Event *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    pDst->present = 1;
    pDst->num_hci_command_packets = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    framesntohs(pCtx, &pDst->command_opcode, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    switch (pDst->command_opcode)
    {
        case 0x0c03:
            pDst->cc_event.Reset.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
        break;
        case 0x0c08:
            pDst->cc_event.Flush.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            framesntohs(pCtx, &pDst->cc_event.Flush.log_link_handle, pBuf, 0);
            pBuf += 2;
            tlvlen -= (v_U8_t)2;
        break;
        case 0x043b:
            pDst->cc_event.Logical_Link_Cancel.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            pDst->cc_event.Logical_Link_Cancel.phy_link_handle = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            pDst->cc_event.Logical_Link_Cancel.tx_flow_spec_id = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
        break;
        case 0x0c05:
            pDst->cc_event.Set_Event_Mask.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
        break;
        case 0x0c15:
            pDst->cc_event.Read_Connection_Accept_TO.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            framesntohs(pCtx, &pDst->cc_event.Read_Connection_Accept_TO.connection_accept_timeout, pBuf, 0);
            pBuf += 2;
            tlvlen -= (v_U8_t)2;
        break;
        case 0x0c16:
            pDst->cc_event.Write_Connection_Accept_TO.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
        break;
        case 0x0c36:
            pDst->cc_event.Read_Link_Supervision_TO.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            framesntohs(pCtx, &pDst->cc_event.Read_Link_Supervision_TO.log_link_handle, pBuf, 0);
            pBuf += 2;
            tlvlen -= (v_U8_t)2;
            framesntohs(pCtx, &pDst->cc_event.Read_Link_Supervision_TO.link_supervision_timeout, pBuf, 0);
            pBuf += 2;
            tlvlen -= (v_U8_t)2;
        break;
        case 0x0c37:
            pDst->cc_event.Write_Link_Supervision_TO.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            framesntohs(pCtx, &pDst->cc_event.Write_Link_Supervision_TO.log_link_handle, pBuf, 0);
            pBuf += 2;
            tlvlen -= (v_U8_t)2;
        break;
        case 0x0c61:
            pDst->cc_event.Read_Logical_Link_Accept_TO.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            framesntohs(pCtx, &pDst->cc_event.Read_Logical_Link_Accept_TO.logical_link_accept_timeout, pBuf, 0);
            pBuf += 2;
            tlvlen -= (v_U8_t)2;
        break;
        case 0x0c62:
            pDst->cc_event.Write_Logical_Link_Accept_TO.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
        break;
        case 0x0c63:
            pDst->cc_event.Set_Event_Mask_Page_2.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
        break;
        case 0x0c64:
            pDst->cc_event.Read_Location_Data.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            pDst->cc_event.Read_Location_Data.loc_domain_aware = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            BTAMP_MEMCPY(pCtx, pDst->cc_event.Read_Location_Data.loc_domain, pBuf, 3);
            pBuf += 3;
            tlvlen -= (v_U8_t)3;
            pDst->cc_event.Read_Location_Data.loc_options = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
        break;
        case 3173:
            pDst->cc_event.Write_Location_Data.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
        break;
        case 3174:
            pDst->cc_event.Read_Flow_Control_Mode.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            pDst->cc_event.Read_Flow_Control_Mode.flow_control_mode = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
        break;
        case 3175:
            pDst->cc_event.Write_Flow_Control_Mode.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
        break;
        case 3177:
            pDst->cc_event.Read_BE_Flush_TO.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            framesntohl(pCtx, &pDst->cc_event.Read_BE_Flush_TO.best_effort_flush_timeout, pBuf, 0);
            pBuf += 4;
            tlvlen -= (v_U8_t)4;
        break;
        case 3178:
            pDst->cc_event.Write_BE_Flush_TO.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
        break;
        case 3179:
            pDst->cc_event.Set_Short_Range_Mode.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
        break;
        case 4097:
            pDst->cc_event.Read_Local_Version_Info.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            pDst->cc_event.Read_Local_Version_Info.HC_HCI_Version = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            framesntohs(pCtx, &pDst->cc_event.Read_Local_Version_Info.HC_HCI_Revision, pBuf, 0);
            pBuf += 2;
            tlvlen -= (v_U8_t)2;
            pDst->cc_event.Read_Local_Version_Info.HC_PAL_Version = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            framesntohs(pCtx, &pDst->cc_event.Read_Local_Version_Info.HC_Manufac_Name, pBuf, 0);
            pBuf += 2;
            tlvlen -= (v_U8_t)2;
            framesntohs(pCtx, &pDst->cc_event.Read_Local_Version_Info.HC_PAL_Sub_Version, pBuf, 0);
            pBuf += 2;
            tlvlen -= (v_U8_t)2;
        break;
        case 4098:
            pDst->cc_event.Read_Local_Supported_Cmds.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            BTAMP_MEMCPY(pCtx, pDst->cc_event.Read_Local_Supported_Cmds.HC_Support_Cmds, pBuf, 64);
            pBuf += 64;
            tlvlen -= (v_U8_t)64;
        break;
        case 4101:
            pDst->cc_event.Read_Buffer_Size.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            framesntohs(pCtx, &pDst->cc_event.Read_Buffer_Size.HC_ACL_Data_Packet_Length, pBuf, 0);
            pBuf += 2;
            tlvlen -= (v_U8_t)2;
            pDst->cc_event.Read_Buffer_Size.HC_SCO_Packet_Length = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            framesntohs(pCtx, &pDst->cc_event.Read_Buffer_Size.HC_Total_Num_ACL_Packets, pBuf, 0);
            pBuf += 2;
            tlvlen -= (v_U8_t)2;
            framesntohs(pCtx, &pDst->cc_event.Read_Buffer_Size.HC_Total_Num_SCO_Packets, pBuf, 0);
            pBuf += 2;
            tlvlen -= (v_U8_t)2;
        break;
        case 4106:
            pDst->cc_event.Read_Data_Block_Size.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            framesntohs(pCtx, &pDst->cc_event.Read_Data_Block_Size.HC_Max_ACL_Data_Packet_Length, pBuf, 0);
            pBuf += 2;
            tlvlen -= (v_U8_t)2;
            framesntohs(pCtx, &pDst->cc_event.Read_Data_Block_Size.HC_Data_Block_Length, pBuf, 0);
            pBuf += 2;
            tlvlen -= (v_U8_t)2;
            framesntohs(pCtx, &pDst->cc_event.Read_Data_Block_Size.HC_Total_Num_Data_Blocks, pBuf, 0);
            pBuf += 2;
            tlvlen -= (v_U8_t)2;
        break;
        case 5121:
            pDst->cc_event.Read_Failed_Contact_Counter.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            framesntohs(pCtx, &pDst->cc_event.Read_Failed_Contact_Counter.log_link_handle, pBuf, 0);
            pBuf += 2;
            tlvlen -= (v_U8_t)2;
            framesntohs(pCtx, &pDst->cc_event.Read_Failed_Contact_Counter.failed_contact_counter, pBuf, 0);
            pBuf += 2;
            tlvlen -= (v_U8_t)2;
        break;
        case 5122:
            pDst->cc_event.Reset_Failed_Contact_Counter.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            framesntohs(pCtx, &pDst->cc_event.Reset_Failed_Contact_Counter.log_link_handle, pBuf, 0);
            pBuf += 2;
            tlvlen -= (v_U8_t)2;
        break;
        case 5123:
            pDst->cc_event.Read_Link_Quality.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            framesntohs(pCtx, &pDst->cc_event.Read_Link_Quality.log_link_handle, pBuf, 0);
            pBuf += 2;
            tlvlen -= (v_U8_t)2;
            pDst->cc_event.Read_Link_Quality.link_quality = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
        break;
        case 5125:
            pDst->cc_event.Read_RSSI.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            pDst->cc_event.Read_RSSI.phy_link_handle = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            pDst->cc_event.Read_RSSI.rssi = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
        break;
        case 5129:
            pDst->cc_event.Read_Local_AMP_Info.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            pDst->cc_event.Read_Local_AMP_Info.HC_AMP_Status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            framesntohl(pCtx, &pDst->cc_event.Read_Local_AMP_Info.HC_Total_BW, pBuf, 0);
            pBuf += 4;
            tlvlen -= (v_U8_t)4;
            framesntohl(pCtx, &pDst->cc_event.Read_Local_AMP_Info.HC_Max_Guaranteed_BW, pBuf, 0);
            pBuf += 4;
            tlvlen -= (v_U8_t)4;
            framesntohl(pCtx, &pDst->cc_event.Read_Local_AMP_Info.HC_Min_Latency, pBuf, 0);
            pBuf += 4;
            tlvlen -= (v_U8_t)4;
            framesntohl(pCtx, &pDst->cc_event.Read_Local_AMP_Info.HC_Max_PDU_Size, pBuf, 0);
            pBuf += 4;
            tlvlen -= (v_U8_t)4;
            pDst->cc_event.Read_Local_AMP_Info.HC_Controller_Type = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            framesntohs(pCtx, &pDst->cc_event.Read_Local_AMP_Info.HC_PAL_Capabilities, pBuf, 0);
            pBuf += 2;
            tlvlen -= (v_U8_t)2;
            framesntohs(pCtx, &pDst->cc_event.Read_Local_AMP_Info.HC_AMP_Assoc_Length, pBuf, 0);
            pBuf += 2;
            tlvlen -= (v_U8_t)2;
            framesntohl(pCtx, &pDst->cc_event.Read_Local_AMP_Info.HC_Max_Flush_Timeout, pBuf, 0);
            pBuf += 4;
            tlvlen -= (v_U8_t)4;
            framesntohl(pCtx, &pDst->cc_event.Read_Local_AMP_Info.HC_BE_Flush_Timeout, pBuf, 0);
            pBuf += 4;
            tlvlen -= (v_U8_t)4;
        break;
        case 5130:
            pDst->cc_event.Read_Read_Local_AMP_Assoc.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            pDst->cc_event.Read_Read_Local_AMP_Assoc.phy_link_handle = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            framesntohs(pCtx, &pDst->cc_event.Read_Read_Local_AMP_Assoc.remaining_length, pBuf, 0);
            pBuf += 2;
            tlvlen -= (v_U8_t)2;
            if (pDst->cc_event.Read_Read_Local_AMP_Assoc.remaining_length > 248){
                        // pDst->cc_event.Read_Read_Local_AMP_Assoc.present = 0;
                        return BTAMP_SKIPPED_BAD_IE;
            }

            BTAMP_MEMCPY(pCtx, pDst->cc_event.Read_Read_Local_AMP_Assoc.AMP_assoc_fragment, pBuf, ( pDst->cc_event.Read_Read_Local_AMP_Assoc.remaining_length ) );
            pBuf += ( pDst->cc_event.Read_Read_Local_AMP_Assoc.remaining_length );
            tlvlen -= ( pDst->cc_event.Read_Read_Local_AMP_Assoc.remaining_length );
        break;
        case 5131:
            pDst->cc_event.Write_Remote_AMP_Assoc.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            pDst->cc_event.Write_Remote_AMP_Assoc.phy_link_handle = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
        break;
        case 6145:
            pDst->cc_event.Read_Loopback_Mode.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
            pDst->cc_event.Read_Loopback_Mode.loopback_mode = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
        break;
        case 6146:
            pDst->cc_event.Write_Loopback_Mode.status = *pBuf;
            pBuf += 1;
            tlvlen -= (v_U8_t)1;
        break;
    }
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Command_Complete_Event. */

typedef v_U32_t (*pfnUnpackTlvHCI_Command_Complete_Event_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Command_Complete_Event*);

#define SigUnpackTlvHCI_Command_Complete_Event ( 0x000a )


v_U32_t btampUnpackTlvHCI_Command_Status_Event(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Command_Status_Event *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    pDst->status = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    pDst->num_hci_command_packets = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    framesntohs(pCtx, &pDst->command_opcode, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Command_Status_Event. */

typedef v_U32_t (*pfnUnpackTlvHCI_Command_Status_Event_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Command_Status_Event*);

#define SigUnpackTlvHCI_Command_Status_Event ( 0x000b )


v_U32_t btampUnpackTlvHCI_Create_Logical_Link_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Create_Logical_Link_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
#ifdef WLAN_BAPHCI_ENABLE_VALIDITY_CHECKING
    if ( WLAN_BAP_PAL_CREATE_LOG_LINK_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING    
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
//      return BTAMP_INVALID_TLV_LENGTH; 
    }
#endif 
    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    pDst->phy_link_handle = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    BTAMP_MEMCPY(pCtx, pDst->tx_flow_spec, pBuf, 18);
    pBuf += 18;
    tlvlen -= (v_U8_t)18;
    BTAMP_MEMCPY(pCtx, pDst->rx_flow_spec, pBuf, 18);
    pBuf += 18;
    tlvlen -= (v_U8_t)18;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Create_Logical_Link_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Create_Logical_Link_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Create_Logical_Link_Cmd*);

#define SigUnpackTlvHCI_Create_Logical_Link_Cmd ( 0x000c )


v_U32_t btampUnpackTlvHCI_Create_Physical_Link_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Create_Physical_Link_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_CREATE_PHY_LINK_TLV_MIN_LEN > tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING    
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    pDst->phy_link_handle = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    pDst->key_length = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    pDst->key_type = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    if (pDst->key_length > 32){
        pDst->present = 0;
        return BTAMP_SKIPPED_BAD_IE;
    }

    BTAMP_MEMCPY(pCtx, pDst->key_material, pBuf, ( pDst->key_length ) );
    pBuf += ( pDst->key_length );
    tlvlen -= ( pDst->key_length );
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Create_Physical_Link_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Create_Physical_Link_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Create_Physical_Link_Cmd*);

#define SigUnpackTlvHCI_Create_Physical_Link_Cmd ( 0x000d )


v_U32_t btampUnpackTlvHCI_Data_Buffer_Overflow_Event(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Data_Buffer_Overflow_Event *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    pDst->link_type = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Data_Buffer_Overflow_Event. */

typedef v_U32_t (*pfnUnpackTlvHCI_Data_Buffer_Overflow_Event_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Data_Buffer_Overflow_Event*);

#define SigUnpackTlvHCI_Data_Buffer_Overflow_Event ( 0x000e )


v_U32_t btampUnpackTlvHCI_Disconnect_Logical_Link_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Disconnect_Logical_Link_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_DISC_LOG_LINK_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    framesntohs(pCtx, &pDst->log_link_handle, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Disconnect_Logical_Link_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Disconnect_Logical_Link_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Disconnect_Logical_Link_Cmd*);

#define SigUnpackTlvHCI_Disconnect_Logical_Link_Cmd ( 0x000f )


v_U32_t btampUnpackTlvHCI_Disconnect_Logical_Link_Complete_Event(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Disconnect_Logical_Link_Complete_Event *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    pDst->status = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    framesntohs(pCtx, &pDst->log_link_handle, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    pDst->reason = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Disconnect_Logical_Link_Complete_Event. */

typedef v_U32_t (*pfnUnpackTlvHCI_Disconnect_Logical_Link_Complete_Event_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Disconnect_Logical_Link_Complete_Event*);

#define SigUnpackTlvHCI_Disconnect_Logical_Link_Complete_Event ( 0x0010 )


v_U32_t btampUnpackTlvHCI_Disconnect_Physical_Link_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Disconnect_Physical_Link_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
#ifdef WLAN_BAPHCI_ENABLE_VALIDITY_CHECKING
    if ( WLAN_BAP_PAL_DISC_PHY_LINK_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
//      return BTAMP_INVALID_TLV_LENGTH; 
    }
#endif      

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    pDst->phy_link_handle = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    pDst->reason = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Disconnect_Physical_Link_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Disconnect_Physical_Link_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Disconnect_Physical_Link_Cmd*);

#define SigUnpackTlvHCI_Disconnect_Physical_Link_Cmd ( 0x0011 )


v_U32_t btampUnpackTlvHCI_Disconnect_Physical_Link_Complete_Event(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Disconnect_Physical_Link_Complete_Event *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
   (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    pDst->status = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    pDst->phy_link_handle = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    pDst->reason = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Disconnect_Physical_Link_Complete_Event. */

typedef v_U32_t (*pfnUnpackTlvHCI_Disconnect_Physical_Link_Complete_Event_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Disconnect_Physical_Link_Complete_Event*);

#define SigUnpackTlvHCI_Disconnect_Physical_Link_Complete_Event ( 0x0012 )


v_U32_t btampUnpackTlvHCI_Flow_Spec_Modify_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Flow_Spec_Modify_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_FLOW_SPEC_MOD_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    framesntohs(pCtx, &pDst->log_link_handle, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    pDst->be_aggr_counter = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    BTAMP_MEMCPY(pCtx, pDst->tx_flow_spec, pBuf, 18);
    pBuf += 18;
    tlvlen -= (v_U8_t)18;
    BTAMP_MEMCPY(pCtx, pDst->rx_flow_spec, pBuf, 18);
    pBuf += 18;
    tlvlen -= (v_U8_t)18;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Flow_Spec_Modify_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Flow_Spec_Modify_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Flow_Spec_Modify_Cmd*);

#define SigUnpackTlvHCI_Flow_Spec_Modify_Cmd ( 0x0013 )


v_U32_t btampUnpackTlvHCI_Flow_Spec_Modify_Complete_Event(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Flow_Spec_Modify_Complete_Event *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    pDst->status = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    framesntohs(pCtx, &pDst->log_link_handle, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Flow_Spec_Modify_Complete_Event. */

typedef v_U32_t (*pfnUnpackTlvHCI_Flow_Spec_Modify_Complete_Event_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Flow_Spec_Modify_Complete_Event*);

#define SigUnpackTlvHCI_Flow_Spec_Modify_Complete_Event ( 0x0014 )


v_U32_t btampUnpackTlvHCI_Flush_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Flush_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_FLUSH_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    framesntohs(pCtx, &pDst->log_link_handle, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Flush_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Flush_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Flush_Cmd*);

#define SigUnpackTlvHCI_Flush_Cmd ( 0x0015 )


v_U32_t btampUnpackTlvHCI_Flush_Occurred_Event(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Flush_Occurred_Event *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    framesntohs(pCtx, &pDst->log_link_handle, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Flush_Occurred_Event. */

typedef v_U32_t (*pfnUnpackTlvHCI_Flush_Occurred_Event_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Flush_Occurred_Event*);

#define SigUnpackTlvHCI_Flush_Occurred_Event ( 0x0016 )


v_U32_t btampUnpackTlvHCI_Generic_AMP_Link_Key_Notification_Event(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Generic_AMP_Link_Key_Notification_Event *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    BTAMP_MEMCPY(pCtx, pDst->bd_addr, pBuf, 6);
    pBuf += 6;
    tlvlen -= (v_U8_t)6;
    BTAMP_MEMCPY(pCtx, pDst->generic_amp_link_key, pBuf, 32);
    pBuf += 32;
    tlvlen -= (v_U8_t)32;
    pDst->key_type = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Generic_AMP_Link_Key_Notification_Event. */

typedef v_U32_t (*pfnUnpackTlvHCI_Generic_AMP_Link_Key_Notification_Event_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Generic_AMP_Link_Key_Notification_Event*);

#define SigUnpackTlvHCI_Generic_AMP_Link_Key_Notification_Event ( 0x0017 )


v_U32_t btampUnpackTlvHCI_Hardware_Error_Event(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Hardware_Error_Event *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    pDst->hardware_code = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Hardware_Error_Event. */

typedef v_U32_t (*pfnUnpackTlvHCI_Hardware_Error_Event_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Hardware_Error_Event*);

#define SigUnpackTlvHCI_Hardware_Error_Event ( 0x0018 )


v_U32_t btampUnpackTlvHCI_Logical_Link_Cancel_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Logical_Link_Cancel_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_CANCEL_LOG_LINK_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    pDst->phy_link_handle = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    pDst->tx_flow_spec_id = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Logical_Link_Cancel_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Logical_Link_Cancel_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Logical_Link_Cancel_Cmd*);

#define SigUnpackTlvHCI_Logical_Link_Cancel_Cmd ( 0x0019 )


v_U32_t btampUnpackTlvHCI_Logical_Link_Complete_Event(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Logical_Link_Complete_Event *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    pDst->status = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    framesntohs(pCtx, &pDst->log_link_handle, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    pDst->phy_link_handle = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Logical_Link_Complete_Event. */

typedef v_U32_t (*pfnUnpackTlvHCI_Logical_Link_Complete_Event_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Logical_Link_Complete_Event*);

#define SigUnpackTlvHCI_Logical_Link_Complete_Event ( 0x001a )


v_U32_t btampUnpackTlvHCI_Loopback_Command_Event(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Loopback_Command_Event *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    BTAMP_MEMCPY(pCtx, pDst->hci_command_packet, pBuf, 64);
    pBuf += 64;
    tlvlen -= (v_U8_t)64;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Loopback_Command_Event. */

typedef v_U32_t (*pfnUnpackTlvHCI_Loopback_Command_Event_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Loopback_Command_Event*);

#define SigUnpackTlvHCI_Loopback_Command_Event ( 0x001b )


v_U32_t btampUnpackTlvHCI_Physical_Link_Complete_Event(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Physical_Link_Complete_Event *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    pDst->status = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    pDst->phy_link_handle = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Physical_Link_Complete_Event. */

typedef v_U32_t (*pfnUnpackTlvHCI_Physical_Link_Complete_Event_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Physical_Link_Complete_Event*);

#define SigUnpackTlvHCI_Physical_Link_Complete_Event ( 0x001c )


v_U32_t btampUnpackTlvHCI_Physical_Link_Loss_Warning_Event(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Physical_Link_Loss_Warning_Event *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    pDst->phy_link_handle = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    pDst->reason = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Physical_Link_Loss_Warning_Event. */

typedef v_U32_t (*pfnUnpackTlvHCI_Physical_Link_Loss_Warning_Event_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Physical_Link_Loss_Warning_Event*);

#define SigUnpackTlvHCI_Physical_Link_Loss_Warning_Event ( 0x001d )


v_U32_t btampUnpackTlvHCI_Physical_Link_Recovery_Event(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Physical_Link_Recovery_Event *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    pDst->phy_link_handle = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Physical_Link_Recovery_Event. */

typedef v_U32_t (*pfnUnpackTlvHCI_Physical_Link_Recovery_Event_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Physical_Link_Recovery_Event*);

#define SigUnpackTlvHCI_Physical_Link_Recovery_Event ( 0x001e )


v_U32_t btampUnpackTlvHCI_Qos_Violation_Event(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Qos_Violation_Event *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    framesntohs(pCtx, &pDst->log_link_handle, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Qos_Violation_Event. */

typedef v_U32_t (*pfnUnpackTlvHCI_Qos_Violation_Event_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Qos_Violation_Event*);

#define SigUnpackTlvHCI_Qos_Violation_Event ( 0x001f )


v_U32_t btampUnpackTlvHCI_Read_Best_Effort_Flush_Timeout_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Read_Best_Effort_Flush_Timeout_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_READ_BE_FLUSH_TIMEOUT_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    framesntohs(pCtx, &pDst->log_link_handle, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Read_Best_Effort_Flush_Timeout_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Read_Best_Effort_Flush_Timeout_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Read_Best_Effort_Flush_Timeout_Cmd*);

#define SigUnpackTlvHCI_Read_Best_Effort_Flush_Timeout_Cmd ( 0x0020 )


v_U32_t btampUnpackTlvHCI_Read_Buffer_Size_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Read_Buffer_Size_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Read_Buffer_Size_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Read_Buffer_Size_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Read_Buffer_Size_Cmd*);

#define SigUnpackTlvHCI_Read_Buffer_Size_Cmd ( 0x0021 )


v_U32_t btampUnpackTlvHCI_Read_Connection_Accept_Timeout_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Read_Connection_Accept_Timeout_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Read_Connection_Accept_Timeout_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Read_Connection_Accept_Timeout_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Read_Connection_Accept_Timeout_Cmd*);

#define SigUnpackTlvHCI_Read_Connection_Accept_Timeout_Cmd ( 0x0022 )


v_U32_t btampUnpackTlvHCI_Read_Data_Block_Size_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Read_Data_Block_Size_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Read_Data_Block_Size_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Read_Data_Block_Size_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Read_Data_Block_Size_Cmd*);

#define SigUnpackTlvHCI_Read_Data_Block_Size_Cmd ( 0x0023 )


v_U32_t btampUnpackTlvHCI_Read_Failed_Contact_Counter_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Read_Failed_Contact_Counter_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_READ_FAILED_CONTACT_CNT_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    framesntohs(pCtx, &pDst->log_link_handle, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Read_Failed_Contact_Counter_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Read_Failed_Contact_Counter_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Read_Failed_Contact_Counter_Cmd*);

#define SigUnpackTlvHCI_Read_Failed_Contact_Counter_Cmd ( 0x0024 )


v_U32_t btampUnpackTlvHCI_Read_Flow_Control_Mode_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Read_Flow_Control_Mode_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Read_Flow_Control_Mode_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Read_Flow_Control_Mode_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Read_Flow_Control_Mode_Cmd*);

#define SigUnpackTlvHCI_Read_Flow_Control_Mode_Cmd ( 0x0025 )


v_U32_t btampUnpackTlvHCI_Read_Link_Quality_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Read_Link_Quality_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_READ_LINK_QUALITY_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    framesntohs(pCtx, &pDst->log_link_handle, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Read_Link_Quality_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Read_Link_Quality_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Read_Link_Quality_Cmd*);

#define SigUnpackTlvHCI_Read_Link_Quality_Cmd ( 0x0026 )


v_U32_t btampUnpackTlvHCI_Read_Link_Supervision_Timeout_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Read_Link_Supervision_Timeout_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_READ_LINK_SVISISON_TIMEOUT_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    framesntohs(pCtx, &pDst->log_link_handle, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Read_Link_Supervision_Timeout_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Read_Link_Supervision_Timeout_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Read_Link_Supervision_Timeout_Cmd*);

#define SigUnpackTlvHCI_Read_Link_Supervision_Timeout_Cmd ( 0x0027 )


v_U32_t btampUnpackTlvHCI_Read_Local_AMP_Assoc_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Read_Local_AMP_Assoc_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s. tlvlen=%d.", __func__, tlvlen); 

#ifdef WLAN_BAPHCI_ENABLE_VALIDITY_CHECKING
    if ( WLAN_BAP_PAL_READ_LOCAL_AMP_ASSOC_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
//      return BTAMP_INVALID_TLV_LENGTH; 
    }
#endif      

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    pDst->phy_link_handle = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    framesntohs(pCtx, &pDst->length_so_far, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    framesntohs(pCtx, &pDst->max_remote_amp_assoc_length, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Read_Local_AMP_Assoc_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Read_Local_AMP_Assoc_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Read_Local_AMP_Assoc_Cmd*);

#define SigUnpackTlvHCI_Read_Local_AMP_Assoc_Cmd ( 0x0028 )


v_U32_t btampUnpackTlvHCI_Read_Local_AMP_Information_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Read_Local_AMP_Information_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
     pDst->present = 1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Read_Local_AMP_Information_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Read_Local_AMP_Information_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Read_Local_AMP_Information_Cmd*);

#define SigUnpackTlvHCI_Read_Local_AMP_Information_Cmd ( 0x0029 )


v_U32_t btampUnpackTlvHCI_Read_Local_Supported_Cmds_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Read_Local_Supported_Cmds_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Read_Local_Supported_Cmds_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Read_Local_Supported_Cmds_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Read_Local_Supported_Cmds_Cmd*);

#define SigUnpackTlvHCI_Read_Local_Supported_Cmds_Cmd ( 0x002a )


v_U32_t btampUnpackTlvHCI_Read_Local_Version_Info_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Read_Local_Version_Info_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Read_Local_Version_Info_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Read_Local_Version_Info_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Read_Local_Version_Info_Cmd*);

#define SigUnpackTlvHCI_Read_Local_Version_Info_Cmd ( 0x002b )


v_U32_t btampUnpackTlvHCI_Read_Location_Data_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Read_Location_Data_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Read_Location_Data_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Read_Location_Data_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Read_Location_Data_Cmd*);

#define SigUnpackTlvHCI_Read_Location_Data_Cmd ( 0x002c )


v_U32_t btampUnpackTlvHCI_Read_Logical_Link_Accept_Timeout_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Read_Logical_Link_Accept_Timeout_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Read_Logical_Link_Accept_Timeout_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Read_Logical_Link_Accept_Timeout_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Read_Logical_Link_Accept_Timeout_Cmd*);

#define SigUnpackTlvHCI_Read_Logical_Link_Accept_Timeout_Cmd ( 0x002d )


v_U32_t btampUnpackTlvHCI_Read_Loopback_Mode_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Read_Loopback_Mode_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Read_Loopback_Mode_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Read_Loopback_Mode_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Read_Loopback_Mode_Cmd*);

#define SigUnpackTlvHCI_Read_Loopback_Mode_Cmd ( 0x002e )


v_U32_t btampUnpackTlvHCI_Read_RSSI_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Read_RSSI_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_READ_RSSI_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    framesntohs(pCtx, &pDst->log_link_handle, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Read_RSSI_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Read_RSSI_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Read_RSSI_Cmd*);

#define SigUnpackTlvHCI_Read_RSSI_Cmd ( 0x002f )


v_U32_t btampUnpackTlvHCI_Reset_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Reset_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Reset_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Reset_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Reset_Cmd*);

#define SigUnpackTlvHCI_Reset_Cmd ( 0x0030 )


v_U32_t btampUnpackTlvHCI_Reset_Failed_Contact_Counter_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Reset_Failed_Contact_Counter_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_RESET_FAILED_CONTACT_CNT_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    framesntohs(pCtx, &pDst->log_link_handle, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Reset_Failed_Contact_Counter_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Reset_Failed_Contact_Counter_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Reset_Failed_Contact_Counter_Cmd*);

#define SigUnpackTlvHCI_Reset_Failed_Contact_Counter_Cmd ( 0x0031 )


v_U32_t btampUnpackTlvHCI_Set_Event_Mask_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Set_Event_Mask_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_SET_EVENT_MASK_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    BTAMP_MEMCPY(pCtx, pDst->event_mask, pBuf, 8);
    pBuf += 8;
    tlvlen -= (v_U8_t)8;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Set_Event_Mask_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Set_Event_Mask_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Set_Event_Mask_Cmd*);

#define SigUnpackTlvHCI_Set_Event_Mask_Cmd ( 0x0032 )


v_U32_t btampUnpackTlvHCI_Set_Event_Mask_Page_2_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Set_Event_Mask_Page_2_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/

      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s. tlvlen=%d.", __func__, tlvlen); 
#ifdef WLAN_BAPHCI_ENABLE_VALIDITY_CHECKING
    if ( WLAN_BAP_PAL_SET_EVENT_MASK2_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
//      return BTAMP_INVALID_TLV_LENGTH; 
    }
#endif      

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    BTAMP_MEMCPY(pCtx, pDst->event_mask_page_2, pBuf, 8);
    pBuf += 8;
    tlvlen -= (v_U8_t)8;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Set_Event_Mask_Page_2_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Set_Event_Mask_Page_2_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Set_Event_Mask_Page_2_Cmd*);

#define SigUnpackTlvHCI_Set_Event_Mask_Page_2_Cmd ( 0x0033 )


v_U32_t btampUnpackTlvHCI_Set_Short_Range_Mode_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Set_Short_Range_Mode_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_SET_SHORT_RANGE_MODE_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    pDst->phy_link_handle = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    pDst->short_range_mode = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Set_Short_Range_Mode_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Set_Short_Range_Mode_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Set_Short_Range_Mode_Cmd*);

#define SigUnpackTlvHCI_Set_Short_Range_Mode_Cmd ( 0x0034 )


v_U32_t btampUnpackTlvHCI_Short_Range_Mode_Change_Complete_Event(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Short_Range_Mode_Change_Complete_Event *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    pDst->status = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    pDst->phy_link_handle = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    pDst->short_range_mode = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Short_Range_Mode_Change_Complete_Event. */

typedef v_U32_t (*pfnUnpackTlvHCI_Short_Range_Mode_Change_Complete_Event_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Short_Range_Mode_Change_Complete_Event*);

#define SigUnpackTlvHCI_Short_Range_Mode_Change_Complete_Event ( 0x0035 )


v_U32_t btampUnpackTlvHCI_Write_Best_Effort_Flush_Timeout_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Write_Best_Effort_Flush_Timeout_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_WRITE_BE_FLUSH_TIMEOUT_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    framesntohs(pCtx, &pDst->log_link_handle, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    framesntohl(pCtx, &pDst->best_effort_flush_timeout, pBuf, 0);
    pBuf += 4;
    tlvlen -= (v_U8_t)4;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Write_Best_Effort_Flush_Timeout_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Write_Best_Effort_Flush_Timeout_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Write_Best_Effort_Flush_Timeout_Cmd*);

#define SigUnpackTlvHCI_Write_Best_Effort_Flush_Timeout_Cmd ( 0x0036 )


v_U32_t btampUnpackTlvHCI_Write_Connection_Accept_Timeout_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Write_Connection_Accept_Timeout_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_WRITE_CON_ACC_TIMEOUT_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    framesntohs(pCtx, &pDst->connection_accept_timeout, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Write_Connection_Accept_Timeout_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Write_Connection_Accept_Timeout_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Write_Connection_Accept_Timeout_Cmd*);

#define SigUnpackTlvHCI_Write_Connection_Accept_Timeout_Cmd ( 0x0037 )


v_U32_t btampUnpackTlvHCI_Write_Flow_Control_Mode_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Write_Flow_Control_Mode_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_WRITE_FLOW_CTRL_MODE_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    pDst->flow_control_mode = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Write_Flow_Control_Mode_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Write_Flow_Control_Mode_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Write_Flow_Control_Mode_Cmd*);

#define SigUnpackTlvHCI_Write_Flow_Control_Mode_Cmd ( 0x0038 )


v_U32_t btampUnpackTlvHCI_Write_Link_Supervision_Timeout_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Write_Link_Supervision_Timeout_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_WRITE_LINK_SVISION_TIMEOUT_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    framesntohs(pCtx, &pDst->log_link_handle, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    framesntohs(pCtx, &pDst->link_supervision_timeout, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Write_Link_Supervision_Timeout_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Write_Link_Supervision_Timeout_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Write_Link_Supervision_Timeout_Cmd*);

#define SigUnpackTlvHCI_Write_Link_Supervision_Timeout_Cmd ( 0x0039 )


v_U32_t btampUnpackTlvHCI_Write_Location_Data_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Write_Location_Data_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_WRITE_LOCATION_DATA_CMD_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    pDst->loc_domain_aware = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    BTAMP_MEMCPY(pCtx, pDst->loc_domain, pBuf, 3);
    pBuf += 3;
    tlvlen -= (v_U8_t)3;
    pDst->loc_options = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Write_Location_Data_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Write_Location_Data_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Write_Location_Data_Cmd*);

#define SigUnpackTlvHCI_Write_Location_Data_Cmd ( 0x003a )


v_U32_t btampUnpackTlvHCI_Write_Logical_Link_Accept_Timeout_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Write_Logical_Link_Accept_Timeout_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_WRITE_LOG_LINK_ACC_TIMEOUT_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    framesntohs(pCtx, &pDst->logical_link_accept_timeout, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Write_Logical_Link_Accept_Timeout_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Write_Logical_Link_Accept_Timeout_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Write_Logical_Link_Accept_Timeout_Cmd*);

#define SigUnpackTlvHCI_Write_Logical_Link_Accept_Timeout_Cmd ( 0x003b )


v_U32_t btampUnpackTlvHCI_Write_Loopback_Mode_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Write_Loopback_Mode_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_WRITE_LOOOPBACK_MODE_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    pDst->loopback_mode = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Write_Loopback_Mode_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Write_Loopback_Mode_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Write_Loopback_Mode_Cmd*);

#define SigUnpackTlvHCI_Write_Loopback_Mode_Cmd ( 0x003c )


v_U32_t btampUnpackTlvHCI_Write_Remote_AMP_ASSOC_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Write_Remote_AMP_ASSOC_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_WRITE_REMOTE_AMP_ASSOC_MIN_TLV_LEN > tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    pDst->phy_link_handle = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    framesntohs(pCtx, &pDst->length_so_far, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    framesntohs(pCtx, &pDst->amp_assoc_remaining_length, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    if (pDst->amp_assoc_remaining_length > 248){
        pDst->present = 0;
        return BTAMP_SKIPPED_BAD_IE;
    }

    BTAMP_MEMCPY(pCtx, pDst->amp_assoc_fragment, pBuf, ( pDst->amp_assoc_remaining_length ) );
    pBuf += ( pDst->amp_assoc_remaining_length );
    tlvlen -= ( pDst->amp_assoc_remaining_length );
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Write_Remote_AMP_ASSOC_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Write_Remote_AMP_ASSOC_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Write_Remote_AMP_ASSOC_Cmd*);

#define SigUnpackTlvHCI_Write_Remote_AMP_ASSOC_Cmd ( 0x003d )

v_U32_t btampUnpackTlvHCI_Enhanced_Flush_Cmd(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Enhanced_Flush_Cmd *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */

    /*-----------------------------------------------------------------------
       TLV Sanity check 
    -------------------------------------------------------------------------*/
    if ( WLAN_BAP_PAL_ENHANCED_FLUSH_TLV_LEN != tlvlen ) 
    {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
      /*Log invalid len*/
      VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, 
            "Invalid TLV len on %s", __func__); 
#endif      
      return BTAMP_INVALID_TLV_LENGTH; 
    }

    /*-----------------------------------------------------------------------
      Parse TLV 
     -----------------------------------------------------------------------*/
    pDst->present = 1;
    framesntohs(pCtx, &pDst->log_link_handle, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    pDst->packet_type = *pBuf;
    pBuf += 1;
    tlvlen -= (v_U8_t)1;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Enhanced_Flush_Cmd. */

typedef v_U32_t (*pfnUnpackTlvHCI_Enhanced_Flush_Cmd_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Enhanced_Flush_Cmd*);

#define SigUnpackTlvHCI_Enhanced_Flush_Cmd ( 0x003e )


v_U32_t btampUnpackTlvHCI_Enhanced_Flush_Complete_Event(void * pCtx, v_U8_t *pBuf, v_U16_t tlvlen, tBtampTLVHCI_Enhanced_Flush_Complete_Event *pDst)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pBuf; (void)tlvlen; /* Shutup the compiler */
    pDst->present = 1;
    framesntohs(pCtx, &pDst->log_link_handle, pBuf, 0);
    pBuf += 2;
    tlvlen -= (v_U8_t)2;
    (void)pCtx;
    return status;
} /* End btampUnpackTlvHCI_Enhanced_Flush_Completed_Event. */

typedef v_U32_t (*pfnUnpackTlvHCI_Enhanced_Flush_Complete_Event_t)(void *, v_U8_t*, v_U16_t, tBtampTLVHCI_Enhanced_Flush_Complete_Event*);

#define SigUnpackTlvHCI_Enhanced_Flush_Complete_Event ( 0x003f )


v_U32_t btampUnpackAMP_ASSOC(void * pCtx, v_U8_t *pBuf, v_U32_t nBuf, tBtampAMP_ASSOC *pFrm)
{
    v_U32_t i;
    static tTLVDefn TLVS[ ] = {
        {BTAMP_TLV_AMP_ASSOC_MAC_ADDR, 0, 9, 9, offsetof(tBtampAMP_ASSOC, AMP_Assoc_MAC_Addr), offsetof(tBtampTLVAMP_Assoc_MAC_Addr, present), SigUnpackTlvAMP_Assoc_MAC_Addr, (pfnGeneric_t)btampUnpackTlvAMP_Assoc_MAC_Addr, "AMP_Assoc_MAC_Addr", 1, },
        {BTAMP_TLV_AMP_ASSOC_PREFERRED_CHANNEL_LIST, 0, 9, 0xFF/*12*/, offsetof(tBtampAMP_ASSOC, AMP_Assoc_Preferred_Channel_List), offsetof(tBtampTLVAMP_Assoc_Preferred_Channel_List, present), SigUnpackTlvAMP_Assoc_Preferred_Channel_List, (pfnGeneric_t)btampUnpackTlvAMP_Assoc_Preferred_Channel_List, "AMP_Assoc_Preferred_Channel_List", 1, },
        {BTAMP_TLV_AMP_ASSOC_CONNECTED_CHANNEL, 0, 9, 0xFF/*12*/, offsetof(tBtampAMP_ASSOC, AMP_Assoc_Connected_Channel), offsetof(tBtampTLVAMP_Assoc_Connected_Channel, present), SigUnpackTlvAMP_Assoc_Connected_Channel, (pfnGeneric_t)btampUnpackTlvAMP_Assoc_Connected_Channel, "AMP_Assoc_Connected_Channel", 0, },
        {BTAMP_TLV_AMP_ASSOC_PAL_CAPABILITIES, 0, 7, 7, offsetof(tBtampAMP_ASSOC, AMP_Assoc_PAL_Capabilities), offsetof(tBtampTLVAMP_Assoc_PAL_Capabilities, present), SigUnpackTlvAMP_Assoc_PAL_Capabilities, (pfnGeneric_t)btampUnpackTlvAMP_Assoc_PAL_Capabilities, "AMP_Assoc_PAL_Capabilities", 0, },
        {BTAMP_TLV_AMP_ASSOC_PAL_VERSION, 0, 8, 8, offsetof(tBtampAMP_ASSOC, AMP_Assoc_PAL_Version), offsetof(tBtampTLVAMP_Assoc_PAL_Version, present), SigUnpackTlvAMP_Assoc_PAL_Version, (pfnGeneric_t)btampUnpackTlvAMP_Assoc_PAL_Version, "AMP_Assoc_PAL_Version", 1, },
    { 0xffff, 0 },
    };

    v_U32_t status = 0;
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
    VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,
      "In btampUnpackAMP_ASSOC. nBuf - %d\n", nBuf); 
#endif    

    status |= UnpackTlvCore(pCtx,pBuf,nBuf,TLVS,(v_U8_t*)pFrm,sizeof(*pFrm));

    (void)i;
#   ifdef BTAMP_DUMP_FRAMES
    if (!BTAMP_FAILED(status))
    {
        FRAMES_LOG0(pCtx, FRAMES_SEV_FOR_FRAME(pCtx, BTAMP_AMP_ASSOC), FRFL("Unpacked the AMP_ASSOC:\n"));
        FRAMES_DUMP(pCtx, FRAMES_SEV_FOR_FRAME(pCtx, BTAMP_AMP_ASSOC), pBuf, nBuf);
        FRAMES_LOG0(pCtx, FRAMES_SEV_FOR_FRAME(pCtx, BTAMP_AMP_ASSOC), FRFL("to:\n"));
        FRAMES_LOG0(pCtx, FRAMES_SEV_FOR_FRAME(pCtx, BTAMP_AMP_ASSOC), FRFL("AMP_Assoc_MAC_Addr:\n"));
        if (!pFrm->AMP_Assoc_MAC_Addr.present)
        {
            FRAMES_LOG0(pCtx, FRAMES_SEV_FOR_FRAME(pCtx, BTAMP_AMP_ASSOC), FRFL("Not present.\n"));
        }
        else
        {
            FRAMES_DUMP(pCtx, FRAMES_SEV_FOR_FRAME(pCtx, BTAMP_AMP_ASSOC), ( v_U8_t* )&pFrm->AMP_Assoc_MAC_Addr.mac_addr, 6);
        }
        FRAMES_LOG0(pCtx, FRAMES_SEV_FOR_FRAME(pCtx, BTAMP_AMP_ASSOC), FRFL("AMP_Assoc_Preferred_Channel_List:\n"));
        if (!pFrm->AMP_Assoc_Preferred_Channel_List.present)
        {
            FRAMES_LOG0(pCtx, FRAMES_SEV_FOR_FRAME(pCtx, BTAMP_AMP_ASSOC), FRFL("Not present.\n"));
        }
        else
        {
            FRAMES_DUMP(pCtx, FRAMES_SEV_FOR_FRAME(pCtx, BTAMP_AMP_ASSOC), ( v_U8_t* )&pFrm->AMP_Assoc_Preferred_Channel_List.country, 3);
            FRAMES_LOG1(pCtx, FRAMES_SEV_FOR_FRAME(pCtx, BTAMP_AMP_ASSOC), FRFL("num_triplets: %d.\n"), pFrm->AMP_Assoc_Preferred_Channel_List.num_triplets);
            FRAMES_DUMP(pCtx, FRAMES_SEV_FOR_FRAME(pCtx, BTAMP_AMP_ASSOC), ( v_U8_t* ) pFrm->AMP_Assoc_Preferred_Channel_List.triplets, 3 * pFrm->AMP_Assoc_Preferred_Channel_List.num_triplets);
        }
        FRAMES_LOG0(pCtx, FRAMES_SEV_FOR_FRAME(pCtx, BTAMP_AMP_ASSOC), FRFL("AMP_Assoc_Connected_Channel:\n"));
        if (!pFrm->AMP_Assoc_Connected_Channel.present)
        {
            FRAMES_LOG0(pCtx, FRAMES_SEV_FOR_FRAME(pCtx, BTAMP_AMP_ASSOC), FRFL("Not present.\n"));
        }
        else
        {
            FRAMES_DUMP(pCtx, FRAMES_SEV_FOR_FRAME(pCtx, BTAMP_AMP_ASSOC), ( v_U8_t* )&pFrm->AMP_Assoc_Connected_Channel.country, 3);
            FRAMES_LOG1(pCtx, FRAMES_SEV_FOR_FRAME(pCtx, BTAMP_AMP_ASSOC), FRFL("num_triplets: %d.\n"), pFrm->AMP_Assoc_Connected_Channel.num_triplets);
            FRAMES_DUMP(pCtx, FRAMES_SEV_FOR_FRAME(pCtx, BTAMP_AMP_ASSOC), ( v_U8_t* ) pFrm->AMP_Assoc_Connected_Channel.triplets, 3 * pFrm->AMP_Assoc_Connected_Channel.num_triplets);
        }
        FRAMES_LOG0(pCtx, FRAMES_SEV_FOR_FRAME(pCtx, BTAMP_AMP_ASSOC), FRFL("AMP_Assoc_PAL_Capabilities:\n"));
        if (!pFrm->AMP_Assoc_PAL_Capabilities.present)
        {
            FRAMES_LOG0(pCtx, FRAMES_SEV_FOR_FRAME(pCtx, BTAMP_AMP_ASSOC), FRFL("Not present.\n"));
        }
        else
        {
            FRAMES_DUMP(pCtx, FRAMES_SEV_FOR_FRAME(pCtx, BTAMP_AMP_ASSOC), ( v_U8_t* )&pFrm->AMP_Assoc_PAL_Capabilities.pal_capabilities, 4);
        }
        FRAMES_LOG0(pCtx, FRAMES_SEV_FOR_FRAME(pCtx, BTAMP_AMP_ASSOC), FRFL("AMP_Assoc_PAL_Version:\n"));
        if (!pFrm->AMP_Assoc_PAL_Version.present)
        {
            FRAMES_LOG0(pCtx, FRAMES_SEV_FOR_FRAME(pCtx, BTAMP_AMP_ASSOC), FRFL("Not present.\n"));
        }
        else
        {
            FRAMES_DUMP(pCtx, FRAMES_SEV_FOR_FRAME(pCtx, BTAMP_AMP_ASSOC), ( v_U8_t* )&pFrm->AMP_Assoc_PAL_Version.pal_version, 1);
            FRAMES_DUMP(pCtx, FRAMES_SEV_FOR_FRAME(pCtx, BTAMP_AMP_ASSOC), ( v_U8_t* )&pFrm->AMP_Assoc_PAL_Version.pal_CompanyID, 2);
            FRAMES_DUMP(pCtx, FRAMES_SEV_FOR_FRAME(pCtx, BTAMP_AMP_ASSOC), ( v_U8_t* )&pFrm->AMP_Assoc_PAL_Version.pal_subversion, 2);
        }
    }
#   endif // BTAMP_DUMP_FRAMES
    return status;

} /* End btampUnpackAMP_ASSOC. */

static v_U32_t UnpackTlvCore( void *   pCtx,
                                   v_U8_t *pBuf,
                                   v_U32_t nBuf,
                                   tTLVDefn     TLVs[ ],
                                   v_U8_t *pFrm,
                                   size_t       nFrm )
{
    tTLVDefn *pTlv;
    v_U32_t      nBufRemaining, status, status2, npec;
    v_U32_t      sType, sLen;
    v_U16_t      id, len;
    v_U8_t      *pBufRemaining, *pfFound;

    (void)pCtx;                 // Shutup the compiler
    (void)nFrm;
    status = BTAMP_PARSE_SUCCESS;
    status2 = BTAMP_PARSE_SUCCESS;
    pBufRemaining = pBuf;
    nBufRemaining = nBuf;
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
    VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,
      "In UnpackTlvCore, nBufRemaining - %d\n", nBufRemaining); 
#endif    

    // While we have data...
    while ( nBufRemaining )
    {
        if ( 3 > nBufRemaining )
        {
            FRAMES_LOG0( pCtx, FRLOGE, FRFL( "This frame reports "
                         "fewer three byte(s) remaining.\n" ) );
            status |= BTAMP_INCOMPLETE_TLV;
            FRAMES_DBG_BREAK();
            goto MandatoryCheck;
        }

        npec = 0U;
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
        VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,
          "Calling FindTLVDefn...\n", nBufRemaining); 
#endif

        // Look for a matching TLV definition,
        pTlv = FindTLVDefn( pCtx, pBufRemaining, nBufRemaining, TLVs );
        sType = 1;
        sLen  = 2;
        // consume the type,
        if (sType == 2) 
            framesntohs(pCtx, &id, pBufRemaining, 1);
        else { 
            id = *pBufRemaining; 
        }
        pBufRemaining += sType;
        nBufRemaining -= sType;
        // & length,
        framesntohs(pCtx, &len, pBufRemaining, 1);
        pBufRemaining += sLen;
        nBufRemaining -= sLen;

        if ( pTlv && pTlv->pec )
        {
            npec = 3U;
            if ( 3 > nBufRemaining )
            {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
                VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,
                  "3 > nBufRemaining\n"); 
#endif

                FRAMES_LOG2(pCtx, FRLOGW, FRFL("TLV %d reports length"
                    "%d, but it has a Private Enterprise Code (3 byte"
                    "s.\n"), id, len);
                FRAMES_DUMP(pCtx, FRLOG1, pBuf, nBuf);
                FRAMES_LOG2(pCtx, FRLOG1, FRFL("We've parsed %d bytes"
                    "of this buffer, and show %d left.\n"),
                pBufRemaining - pBuf, nBufRemaining);
                status |= BTAMP_INCOMPLETE_TLV;
                FRAMES_DBG_BREAK();
                goto MandatoryCheck;
            }
            pBufRemaining += 3;
            nBufRemaining -= 3;
            len           -= 3;
        }
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
        VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,
          "Len - %d nBufRemaining - %d\n", len, nBufRemaining); 
#endif

        // Whether we found a hit or not, we can validate the reported
        // length of this TLV:
        if ( len > nBufRemaining )
        {
            FRAMES_LOG3(pCtx, FRLOGW, FRFL("TLV %d reports length %"
                "d, but there are only %d bytes remaining in this f"
                "rame.\n"), id, len, nBufRemaining );
            FRAMES_DUMP( pCtx, FRLOG1, pBuf, nBuf );
            FRAMES_LOG2( pCtx, FRLOG1, FRFL( "We've parsed %d bytes"
                " of this buffer, and show %d left.\n"),
                pBufRemaining - pBuf, nBufRemaining);
            status |= BTAMP_INCOMPLETE_TLV;
            FRAMES_DBG_BREAK();
            goto MandatoryCheck;
        }

        // Now, *if* we found a hit...
        if ( pTlv )
        {
            if ( nBufRemaining < pTlv->minSize - npec - (sType + sLen))
            {
                FRAMES_LOG3( pCtx, FRLOGW, FRFL("The IE %s must be "
                    "at least %d bytes in size, but there are only "
                    "%d bytes remaining in this frame.\n"),
                     pTlv->name, pTlv->minSize, nBufRemaining );
                FRAMES_DUMP( pCtx, FRLOG1, pBuf, nBuf );
                status |= BTAMP_INCOMPLETE_TLV;
                FRAMES_DBG_BREAK( );
                goto MandatoryCheck;
            }
            else if ( len > pTlv->maxSize - npec - (sType + sLen))
            {
                FRAMES_LOG1( pCtx, FRLOGW, FRFL("The TLV %s reports "
                    "an illegally large size; this TLV is presumably"
                    "corrupt or otherwise invalid & will be skipped "
                    "ipped.\n"), pTlv->name );
                FRAMES_DUMP( pCtx, FRLOG1, pBuf, nBuf );
                FRAMES_LOG2( pCtx, FRLOG1, FRFL("We've parsed %d by"
                    "tes of this buffer, and show %d left.\n"),
                    pBufRemaining - pBuf, nBufRemaining);
                FRAMES_DBG_BREAK();
                status |= BTAMP_SKIPPED_BAD_TLV;
            }
            else
            {
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
                VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,
                  "pTlv->sig - %d\n", pTlv->sig); 
#endif

                switch (pTlv->sig)
                {
                case SigUnpackTlvAMP_Assoc_Connected_Channel:
                        status2 = ( (pfnUnpackTlvAMP_Assoc_Connected_Channel_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVAMP_Assoc_Connected_Channel* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvAMP_Assoc_MAC_Addr:
                        status2 = ( (pfnUnpackTlvAMP_Assoc_MAC_Addr_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVAMP_Assoc_MAC_Addr* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvAMP_Assoc_PAL_Capabilities:
                        status2 = ( (pfnUnpackTlvAMP_Assoc_PAL_Capabilities_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVAMP_Assoc_PAL_Capabilities* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvAMP_Assoc_PAL_Version:
                        status2 = ( (pfnUnpackTlvAMP_Assoc_PAL_Version_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVAMP_Assoc_PAL_Version* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvAMP_Assoc_Preferred_Channel_List:
                        status2 = ( (pfnUnpackTlvAMP_Assoc_Preferred_Channel_List_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVAMP_Assoc_Preferred_Channel_List* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvFlow_Spec:
                        status2 = ( (pfnUnpackTlvFlow_Spec_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVFlow_Spec* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Accept_Logical_Link_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Accept_Logical_Link_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Accept_Logical_Link_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Accept_Physical_Link_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Accept_Physical_Link_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Accept_Physical_Link_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Channel_Selected_Event:
                        status2 = ( (pfnUnpackTlvHCI_Channel_Selected_Event_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Channel_Selected_Event* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Command_Complete_Event:
                        status2 = ( (pfnUnpackTlvHCI_Command_Complete_Event_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Command_Complete_Event* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Command_Status_Event:
                        status2 = ( (pfnUnpackTlvHCI_Command_Status_Event_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Command_Status_Event* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Create_Logical_Link_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Create_Logical_Link_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Create_Logical_Link_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Create_Physical_Link_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Create_Physical_Link_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Create_Physical_Link_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Data_Buffer_Overflow_Event:
                        status2 = ( (pfnUnpackTlvHCI_Data_Buffer_Overflow_Event_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Data_Buffer_Overflow_Event* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Disconnect_Logical_Link_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Disconnect_Logical_Link_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Disconnect_Logical_Link_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Disconnect_Logical_Link_Complete_Event:
                        status2 = ( (pfnUnpackTlvHCI_Disconnect_Logical_Link_Complete_Event_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Disconnect_Logical_Link_Complete_Event* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Disconnect_Physical_Link_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Disconnect_Physical_Link_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Disconnect_Physical_Link_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Disconnect_Physical_Link_Complete_Event:
                        status2 = ( (pfnUnpackTlvHCI_Disconnect_Physical_Link_Complete_Event_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Disconnect_Physical_Link_Complete_Event* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Flow_Spec_Modify_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Flow_Spec_Modify_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Flow_Spec_Modify_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Flow_Spec_Modify_Complete_Event:
                        status2 = ( (pfnUnpackTlvHCI_Flow_Spec_Modify_Complete_Event_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Flow_Spec_Modify_Complete_Event* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Flush_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Flush_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Flush_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Flush_Occurred_Event:
                        status2 = ( (pfnUnpackTlvHCI_Flush_Occurred_Event_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Flush_Occurred_Event* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Generic_AMP_Link_Key_Notification_Event:
                        status2 = ( (pfnUnpackTlvHCI_Generic_AMP_Link_Key_Notification_Event_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Generic_AMP_Link_Key_Notification_Event* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Hardware_Error_Event:
                        status2 = ( (pfnUnpackTlvHCI_Hardware_Error_Event_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Hardware_Error_Event* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Logical_Link_Cancel_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Logical_Link_Cancel_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Logical_Link_Cancel_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Logical_Link_Complete_Event:
                        status2 = ( (pfnUnpackTlvHCI_Logical_Link_Complete_Event_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Logical_Link_Complete_Event* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Loopback_Command_Event:
                        status2 = ( (pfnUnpackTlvHCI_Loopback_Command_Event_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Loopback_Command_Event* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Physical_Link_Complete_Event:
                        status2 = ( (pfnUnpackTlvHCI_Physical_Link_Complete_Event_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Physical_Link_Complete_Event* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Physical_Link_Loss_Warning_Event:
                        status2 = ( (pfnUnpackTlvHCI_Physical_Link_Loss_Warning_Event_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Physical_Link_Loss_Warning_Event* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Physical_Link_Recovery_Event:
                        status2 = ( (pfnUnpackTlvHCI_Physical_Link_Recovery_Event_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Physical_Link_Recovery_Event* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Qos_Violation_Event:
                        status2 = ( (pfnUnpackTlvHCI_Qos_Violation_Event_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Qos_Violation_Event* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Read_Best_Effort_Flush_Timeout_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Read_Best_Effort_Flush_Timeout_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Read_Best_Effort_Flush_Timeout_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Read_Buffer_Size_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Read_Buffer_Size_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Read_Buffer_Size_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Read_Connection_Accept_Timeout_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Read_Connection_Accept_Timeout_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Read_Connection_Accept_Timeout_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Read_Data_Block_Size_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Read_Data_Block_Size_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Read_Data_Block_Size_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Read_Failed_Contact_Counter_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Read_Failed_Contact_Counter_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Read_Failed_Contact_Counter_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Read_Flow_Control_Mode_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Read_Flow_Control_Mode_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Read_Flow_Control_Mode_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Read_Link_Quality_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Read_Link_Quality_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Read_Link_Quality_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Read_Link_Supervision_Timeout_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Read_Link_Supervision_Timeout_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Read_Link_Supervision_Timeout_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Read_Local_AMP_Assoc_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Read_Local_AMP_Assoc_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Read_Local_AMP_Assoc_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Read_Local_AMP_Information_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Read_Local_AMP_Information_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Read_Local_AMP_Information_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Read_Local_Supported_Cmds_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Read_Local_Supported_Cmds_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Read_Local_Supported_Cmds_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Read_Local_Version_Info_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Read_Local_Version_Info_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Read_Local_Version_Info_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Read_Location_Data_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Read_Location_Data_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Read_Location_Data_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Read_Logical_Link_Accept_Timeout_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Read_Logical_Link_Accept_Timeout_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Read_Logical_Link_Accept_Timeout_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Read_Loopback_Mode_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Read_Loopback_Mode_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Read_Loopback_Mode_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Read_RSSI_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Read_RSSI_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Read_RSSI_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Reset_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Reset_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Reset_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Reset_Failed_Contact_Counter_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Reset_Failed_Contact_Counter_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Reset_Failed_Contact_Counter_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Set_Event_Mask_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Set_Event_Mask_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Set_Event_Mask_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Set_Event_Mask_Page_2_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Set_Event_Mask_Page_2_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Set_Event_Mask_Page_2_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Set_Short_Range_Mode_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Set_Short_Range_Mode_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Set_Short_Range_Mode_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Short_Range_Mode_Change_Complete_Event:
                        status2 = ( (pfnUnpackTlvHCI_Short_Range_Mode_Change_Complete_Event_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Short_Range_Mode_Change_Complete_Event* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Write_Best_Effort_Flush_Timeout_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Write_Best_Effort_Flush_Timeout_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Write_Best_Effort_Flush_Timeout_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Write_Connection_Accept_Timeout_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Write_Connection_Accept_Timeout_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Write_Connection_Accept_Timeout_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Write_Flow_Control_Mode_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Write_Flow_Control_Mode_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Write_Flow_Control_Mode_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Write_Link_Supervision_Timeout_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Write_Link_Supervision_Timeout_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Write_Link_Supervision_Timeout_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Write_Location_Data_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Write_Location_Data_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Write_Location_Data_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Write_Logical_Link_Accept_Timeout_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Write_Logical_Link_Accept_Timeout_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Write_Logical_Link_Accept_Timeout_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Write_Loopback_Mode_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Write_Loopback_Mode_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Write_Loopback_Mode_Cmd* )(pFrm + pTlv->offset ));
                    break;
                case SigUnpackTlvHCI_Write_Remote_AMP_ASSOC_Cmd:
                        status2 = ( (pfnUnpackTlvHCI_Write_Remote_AMP_ASSOC_Cmd_t)(pTlv->pfn) )(pCtx, pBufRemaining, len, ( tBtampTLVHCI_Write_Remote_AMP_ASSOC_Cmd* )(pFrm + pTlv->offset ));
                    break;
                default:
                    FRAMES_LOG1(pCtx, FRLOGE, FRFL("INTERNAL ERROR: I"
                        " don't know about the TLV signature %d-- thi"
                        "s is most likely a 'framesc' bug.\n"),
                        pTlv->sig);
                    FRAMES_DBG_BREAK();
                    return BTAMP_INTERNAL_ERROR;
                } // End switch on sig.
            } // End if on length check.

            status |= status2;
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
            VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,
              "status - %x\n", status); 
#endif
        }
        else
        {
            FRAMES_LOG2(pCtx, FRLOG3, FRFL("Skipping unknown TLV %d ("
                "length %d)\n"), id, len);
            FRAMES_DUMP(pCtx, FRLOG3, pBufRemaining - (sType + sLen), len);
            status |= BTAMP_UNKNOWN_TLVS;
        }

        // Advance to the next TLV
        pBufRemaining += len;
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
        VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,
          "len - %d nBufRemaining - %d\n", len, nBufRemaining); 
#endif

        if (len > nBufRemaining)
         {
             FRAMES_LOG0(pCtx, FRLOGW, FRFL("This TLV extends past th"
                 "e buffer as it was defined to us.  This could mean "
                 "a corrupt frame, or just an incorrect length parame"
                 "ter.\n"));
             FRAMES_DBG_BREAK();
             status |= BTAMP_LAST_TLV_TOO_LONG;
             goto MandatoryCheck;
         }

        nBufRemaining -= len;

    } // End iteration over TLVs.

MandatoryCheck:
    pTlv = &TLVs[0];
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
    VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,
      "pTlv->id - %x\n", pTlv->id); 
#endif    

    while (0xffff != pTlv->id)
    {
        if (pTlv->fMandatory)
        {
            pfFound = (v_U8_t*)(pFrm + pTlv->offset +
                             pTlv->presenceOffset);
            if (!*pfFound)
            {
                FRAMES_LOG1(pCtx, FRLOGW, FRFL("ERROR: The mandatory "
                    "TLV %s wasn't seen.\n"),
                    pTlv->name);
                FRAMES_DBG_BREAK();
                status |= BTAMP_MANDATORY_TLV_MISSING;
            }

        }
        ++pTlv;
    }

    return status;
} /* End UnpacTlvkCore. */
v_U32_t btampGetPackedTlvAMP_Assoc_Connected_Channel(void * pCtx, tBtampTLVAMP_Assoc_Connected_Channel *pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
    VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,
      "In btampGetPackedTlvAMP_Assoc_Connected_Channel\n"); 
#endif    

    while ( pTlv->present )
    {
        *pnNeeded += 3;
        if ( pTlv->num_triplets )
        {
            *pnNeeded += ( pTlv->num_triplets * 3 );
        }
        else break;
        break;
    }
    return status;
} /* End btampGetPackedTLVAMP_Assoc_Connected_Channel. */

typedef v_U32_t (*pfnPackSizeTlvAMP_Assoc_Connected_Channel_t)(void *, tBtampTLVAMP_Assoc_Connected_Channel*, v_U32_t*);
#define SigPackSizeTlvAMP_Assoc_Connected_Channel ( 0x003e )

v_U32_t btampGetPackedTlvAMP_Assoc_MAC_Addr(void * pCtx, tBtampTLVAMP_Assoc_MAC_Addr *pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
    VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,
      "In btampGetPackedTlvAMP_Assoc_MAC_Addr\n"); 
#endif    

    while ( pTlv->present )
    {
        *pnNeeded += 6;
        break;
    }
    return status;
} /* End btampGetPackedTLVAMP_Assoc_MAC_Addr. */

typedef v_U32_t (*pfnPackSizeTlvAMP_Assoc_MAC_Addr_t)(void *, tBtampTLVAMP_Assoc_MAC_Addr*, v_U32_t*);
#define SigPackSizeTlvAMP_Assoc_MAC_Addr ( 0x003f )

v_U32_t btampGetPackedTlvAMP_Assoc_PAL_Capabilities(void * pCtx, tBtampTLVAMP_Assoc_PAL_Capabilities *pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
    VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,
      "In btampGetPackedTlvAMP_Assoc_PAL_Capabilities\n"); 
#endif    

    while ( pTlv->present )
    {
        *pnNeeded += 4;
        break;
    }
    return status;
} /* End btampGetPackedTLVAMP_Assoc_PAL_Capabilities. */

typedef v_U32_t (*pfnPackSizeTlvAMP_Assoc_PAL_Capabilities_t)(void *, tBtampTLVAMP_Assoc_PAL_Capabilities*, v_U32_t*);
#define SigPackSizeTlvAMP_Assoc_PAL_Capabilities ( 0x0040 )

v_U32_t btampGetPackedTlvAMP_Assoc_PAL_Version(void * pCtx, tBtampTLVAMP_Assoc_PAL_Version *pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        *pnNeeded += 2;
        *pnNeeded += 2;
        break;
    }
    return status;
} /* End btampGetPackedTLVAMP_Assoc_PAL_Version. */

typedef v_U32_t (*pfnPackSizeTlvAMP_Assoc_PAL_Version_t)(void *, tBtampTLVAMP_Assoc_PAL_Version*, v_U32_t*);
#define SigPackSizeTlvAMP_Assoc_PAL_Version ( 0x0041 )

v_U32_t btampGetPackedTlvAMP_Assoc_Preferred_Channel_List(void * pCtx, tBtampTLVAMP_Assoc_Preferred_Channel_List *pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
#ifdef WLAN_BAPHCI_ENABLE_LOGGING
    VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,
      "In btampGetPackedTlvAMP_Assoc_Preferred_Channel_List\n"); 
#endif    

    while ( pTlv->present )
    {
        *pnNeeded += 3;
        if ( pTlv->num_triplets )
        {
            *pnNeeded += ( pTlv->num_triplets * 3 );
        }
        else break;
        break;
    }
    return status;
} /* End btampGetPackedTLVAMP_Assoc_Preferred_Channel_List. */

typedef v_U32_t (*pfnPackSizeTlvAMP_Assoc_Preferred_Channel_List_t)(void *, tBtampTLVAMP_Assoc_Preferred_Channel_List*, v_U32_t*);
#define SigPackSizeTlvAMP_Assoc_Preferred_Channel_List ( 0x0042 )

v_U32_t btampGetPackedTlvFlow_Spec(void * pCtx, tBtampTLVFlow_Spec *pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        *pnNeeded += 1;
        *pnNeeded += 2;
        *pnNeeded += 4;
        *pnNeeded += 4;
        *pnNeeded += 4;
        break;
    }
    return status;
} /* End btampGetPackedTLVFlow_Spec. */

typedef v_U32_t (*pfnPackSizeTlvFlow_Spec_t)(void *, tBtampTLVFlow_Spec*, v_U32_t*);
#define SigPackSizeTlvFlow_Spec ( 0x0043 )

v_U32_t btampGetPackedTlvHCI_Accept_Logical_Link_Cmd(void * pCtx, tBtampTLVHCI_Accept_Logical_Link_Cmd *pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        *pnNeeded += 18;
        *pnNeeded += 18;
        break;
    }
    return status;
} /* End btampGetPackedTLVHCI_Accept_Logical_Link_Cmd. */

typedef v_U32_t (*pfnPackSizeTlvHCI_Accept_Logical_Link_Cmd_t)(void *, tBtampTLVHCI_Accept_Logical_Link_Cmd*, v_U32_t*);
#define SigPackSizeTlvHCI_Accept_Logical_Link_Cmd ( 0x0044 )

v_U32_t btampGetPackedTlvHCI_Accept_Physical_Link_Cmd(void * pCtx, tBtampTLVHCI_Accept_Physical_Link_Cmd *pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        *pnNeeded += 1;
        *pnNeeded += 1;
        *pnNeeded += pTlv->key_length;
        break;
    }
    return status;
} /* End btampGetPackedTLVHCI_Accept_Physical_Link_Cmd. */

typedef v_U32_t (*pfnPackSizeTlvHCI_Accept_Physical_Link_Cmd_t)(void *, tBtampTLVHCI_Accept_Physical_Link_Cmd*, v_U32_t*);
#define SigPackSizeTlvHCI_Accept_Physical_Link_Cmd ( 0x0045 )

v_U32_t btampGetPackedTlvHCI_Channel_Selected_Event(void * pCtx, tBtampTLVHCI_Channel_Selected_Event *pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        break;
    }
    return status;
} /* End btampGetPackedTLVHCI_Channel_Selected_Event. */

typedef v_U32_t (*pfnPackSizeTlvHCI_Channel_Selected_Event_t)(void *, tBtampTLVHCI_Channel_Selected_Event*, v_U32_t*);
#define SigPackSizeTlvHCI_Channel_Selected_Event ( 0x0046 )

v_U32_t btampGetPackedTlvHCI_Command_Complete_Event(void * pCtx, tBtampTLVHCI_Command_Complete_Event *pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        *pnNeeded += 2;
        switch (pTlv->command_opcode)
        {
            case 3075:
                *pnNeeded += 1;
            break;
            case 3080:
                *pnNeeded += 1;
                *pnNeeded += 2;
            break;
            case 1083:
                *pnNeeded += 1;
                *pnNeeded += 1;
                *pnNeeded += 1;
            break;
            case 30777
                *pnNeeded += 1;
            break;
            case 3089:
                *pnNeeded += 1;
                *pnNeeded += 1;
            break;
            case 10894
                *pnNeeded += 1;
            break;
            case 30126
                *pnNeeded += 1;
                *pnNeeded += 1;
            b   *pnNeeded += 1;
            break;
            case 10127
                *pnNeeded += 1;
            b   *pnNeeded += 1;
            break;
            case 10169
                *pnNeeded += 1;
            b   *pnNeeded += 1;
            break;
            case 1017:
                *pnNeeded += 1;
             reak;
            case 10171
                *pnNeeded += 1;
             reak;
            case 10172
                *pnNeeded += 1;
                *pnNeeded += 1;
                *pnNeeded += 13
                *pnNeeded += 1;
            break;
            case 3017:
                *pnNeeded += 1;
             reak;
            case 30174
                *pnNeeded += 1;
            b   *pnNeeded += 1;
             reak;
            case 3017:
                *pnNeeded += 1;
            break;
            case 30177
                *pnNeeded += 1;
            b   *pnNeeded += 14
            break;
            case 30178
                *pnNeeded += 1;
            break;
            case 30179
                *pnNeeded += 1;
            break;
            case 34097
                *pnNeeded += 1;
            b   *pnNeeded += 1;
                *pnNeeded += 1;
            b   *pnNeeded += 1;
                *pnNeeded += 1;
            b   *pnNeeded += 1;
            break;
            case 14098
                *pnNeeded += 1;
            b   *pnNeeded += 164
            break;
            case 34101
                *pnNeeded += 1;
                *pnNeeded += 1;
            b   *pnNeeded += 1;
                *pnNeeded += 1;
            b   *pnNeeded += 1;
            break;
            case 14106
                *pnNeeded += 1;
                *pnNeeded += 1;
            b   *pnNeeded += 1;
            b   *pnNeeded += 1;
            break;
            case 15121
                *pnNeeded += 1;
                *pnNeeded += 1;
            b   *pnNeeded += 1;
            break;
            case 15122
                *pnNeeded += 1;
                *pnNeeded += 1;
            break;
            case 1512:
                *pnNeeded += 1;
                *pnNeeded += 1;
            b   *pnNeeded += 1;
             reak;
            case 1512:
                *pnNeeded += 1;
            b   *pnNeeded += 1;
            b   *pnNeeded += 1;
            break;
            case 15129
                *pnNeeded += 1;
            b   *pnNeeded += 1;
            b   *pnNeeded += 14
            b   *pnNeeded += 14
            b   *pnNeeded += 14
            b   *pnNeeded += 14
            b   *pnNeeded += 1;
                *pnNeeded += 1;
            b   *pnNeeded += 1;
            b   *pnNeeded += 14
            b   *pnNeeded += 14
            break;
            case 1513:
                *pnNeeded += 1;
                *pnNeeded += 2;
                *pnNeeded += 1;
            b   *pnNeeded += 1Tlv->coc_eent. ead_RSad_Local_AMP_Assoc_.emaining length;
        b   break;
            case 15131
                *pnNeeded += 1;
                *pnNeeded += 1;
            break;
            case 1614:
                *pnNeeded += 1;
            b   *pnNeeded += 1;
            break;
            case 16146
                *pnNeeded += 1;
             reak;
         
        ereak;
    }
    return status;
} /* End btampGetPackedTLVHCI_Chmmand_Complete_Event  */

typedef v_U32_t (*pfnPackSizeTlvHCI_Chmmand_Complete_Event_t)(poid *, tBtampTLVHCI_Chmmand_Complete_Event*  v_U32_t*);
#define SigPackSizeTlvHCI_Chmmand_Complete_Event * 0x00467)

v_U32_t btampGetPackedTlvHCI_Command_Ctatus_Event*void * pCtx, tBtampTLVHCI_Command_Ctatus_Event**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        *pnNeeded += 2;
        *pnNeeded += 2;
        sreak;
    }
    return status;
} /* End btampGetPackedTLVHCI_Chmmand_Ctatus_Event* */

typedef v_U32_t (*pfnPackSizeTlvHCI_Chmmand_Ctatus_Event_t)(poid *, tBtampTLVHCI_Chmmand_Ctatus_Event*  v_U32_t*);
#define SigPackSizeTlvHCI_Chmmand_Ctatus_Event** 0x00468)

v_U32_t btampGetPackedTlvHCI_Corate_Logical_Link_Cmd*void * pCtx, tBtampTLVHCI_Corate_Logical_Link_Cmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        *pnNeeded += 2;;
        *pnNeeded += 18;
        break;
    }
    return status;
} /* End btampGetPackedTLVHCI_Aorate_Logical_Link_Cmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_Chrate_Logical_Link_Cmd*t)(poid *, tBtampTLVHCI_Chrate_Logical_Link_Cmd*  v_U32_t*);
#define SigPackSizeTlvHCI_Chrate_Logical_Link_Cmd** 0x00469)

v_U32_t btampGetPackedTlvHCI_Corate_Lhysical_Link_Cmd(void * pCtx, tBtampTLVHCI_Aorate_Lhysical_Link_Cmd(*pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        *pnNeeded += 2;
        *pnNeeded += 2;
        *pnNeeded += 2Tlv->key_length;
        break;
    }
    return status;
} /* End btampGetPackedTLVHCI_Aorate_Lhysical_Link_Cmd( */

typedef v_U32_t (*pfnPackSizeTlvHCI_Chrate_Lhysical_Link_Cmd_t)(void *, tBtampTLVHCI_Areate_Physical_Link_Cmd*  v_U32_t*);
#define SigPackSizeTlvHCI_Chrate_Lhysical_Link_Cmd ( 0x0045a)

v_U32_t btampGetPackedTlvHCI_Cata_Buffer_Overflow_Event*void * pCtx, tBtampTLVHCI_Aata_Buffer_Overflow_Event**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        *reak;
    }
    return status;
} /* End btampGetPackedTLVHCI_Aata_Buffer_Overflow_Event* */

typedef v_U32_t (*pfnPackSizeTlvHCI_Cata_Buffer_Overflow_Event_t)(poid *, tBtampTLVHCI_Aata_Buffer_Overflow_Event*  v_U32_t*);
#define SigPackSizeTlvHCI_Cata_Buffer_Overflow_Event** 0x0045b)

v_U32_t btampGetPackedTlvHCI_Casconnect_Logical_Link_Cmd*void * pCtx, tBtampTLVHCI_Aasconnect_Logical_Link_Cmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        sreak;
    }
    return status;
} /* End btampGetPackedTLVHCI_Casconnect_Logical_Link_Cmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_Casconnect_Logical_Link_Cmd_t)(poid *, tBtampTLVHCI_Aasconnect_Logical_Link_Cmd*  v_U32_t*);
#define SigPackSizeTlvHCI_Casconnect_Logical_Link_Cmd** 0x0045c)

v_U32_t btampGetPackedTlvHCI_Casconnect_Logical_Link_Cmmplete_Event(void * pCtx, tBtampTLVHCI_Casconnect_Logical_Link_Cmmplete_Event(*pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        *pnNeeded += 2;
        *pnNeeded += 4;
        *reak;
    }
    return status;
} /* End btampGetPackedTLVHCI_Aasconnect_Logical_Link_Cmmplete_Event( */

typedef v_U32_t (*pfnPackSizeTlvHCI_Casconnect_Logical_Link_Cmmplete_Event_t)(poid *, tBtampTLVHCI_Cisconnect_Logical_Link_Complete_Event*  v_U32_t*);
#define SigPackSizeTlvHCI_Casconnect_Logical_Link_Cmmplete_Event * 0x0046d)

v_U32_t btampGetPackedTlvHCI_Casconnect_Lhysical_Link_Cmd(void * pCtx, tBtampTLVHCI_Aasconnect_Lhysical_Link_Cmd(*pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        *pnNeeded += 2;
        *reak;
    }
    return status;
} /* End btampGetPackedTLVHCI_Aasconnect_Lhysical_Link_Cmd( */

typedef v_U32_t (*pfnPackSizeTlvHCI_Cisconnect_Physical_Link_Cmd_t)(poid *, tBtampTLVHCI_Cisconnect_Lhysical_Link_Cmd*  v_U32_t*);
#define SigPackSizeTlvHCI_Casconnect_Lhysical_Link_Cmd(* 0x0046 )

v_U32_t btampGetPackedTlvACI_Casconnect_Lhysical_Link_Cmmplete_Event(void * pCtx, tBtampTLVHCI_Casconnect_Lhysical_Link_Cmmplete_Event(*pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        *pnNeeded += 2;
        *pnNeeded += 2;
        *reak;
    }
    return status;
} /* End btampGetPackedTLVHCI_Aasconnect_Lhysical_Link_Cmmplete_Event( */

typedef v_U32_t (*pfnPackSizeTlvHCI_Casconnect_Lhysical_Link_Complete_Event_t)(poid *, tBtampTLVHCI_Cisconnect_Lhysical_Link_Cmmplete_Event*  v_U32_t*);
#define SigPackSizeTlvHCI_Casconnect_Lhysical_Link_Cmmplete_Event(* 0x0046 )

v_U32_t btampGetPackedTlvACI_Clow_Spec_Modify_Cmd*void * pCtx, tBtampTLVHCI_Clow_Spec_Modify_Cmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        *pnNeeded += 4;
        *pnNeeded += 2;;
        *pnNeeded += 18;
        break;
    }
    return status;
} /* End btampGetPackedTLVHCI_Alow_Spec_Modify_Cmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_Clow_Spec_Modify_Cmd_t)(poid *, tBtampTLVHCI_Clow_Spec_Modify_Cmd*  v_U32_t*);
#define SigPackSizeTlvHCI_Clow_Spec_Modify_Cmd** 0x0045 )

v_U32_t btampGetPackedTlvACI_Clow_Spec_Modify_Cmmplete_Event(void * pCtx, tBtampTLVHCI_Clow_Spec_Modify_Cmmplete_Event(*pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        *pnNeeded += 2;
        sreak;
    }
    return status;
} /* End btampGetPackedTLVHCI_Clow_Spec_Modify_Cmmplete_Event( */

typedef v_U32_t (*pfnPackSizeTlvHCI_Clow_Spec_Modify_Cmmplete_Event_t)(poid *, tBtampTLVHCI_Clow_Spec_Modify_Complete_Event*  v_U32_t*);
#define SigPackSizeTlvHCI_Clow_Spec_Modify_Cmmplete_Event(* 0x0045 )

v_U32_t btampGetPackedTlvACI_Closh_Cmd*void * pCtx, tBtampTLVHCI_Closh_Cmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        sreak;
    }
    return status;
} /* End btampGetPackedTLVHCI_Closh_Cmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_Closh_Cmd_t)(poid *, tBtampTLVHCI_Closh_Cmd*  v_U32_t*);
#define SigPackSizeTlvHCI_Closh_Cmd** 0x0045 )

v_U32_t btampGetPackedTlvFCI_Closh_Cccurred_Event*void * pCtx, tBtampTLVHCI_Closh_Cccurred_Event**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        sreak;
    }
    return status;
} /* End btampGetPackedTLVHCI_Closh_Cccurred_Event* */

typedef v_U32_t (*pfnPackSizeTlvHCI_Closh_Cccurred_Event_t)(poid *, tBtampTLVHCI_Closh_Cccurred_Event*  v_U32_t*);
#define SigPackSizeTlvHCI_Closh_Cccurred_Event** 0x0045 )

v_U32_t btampGetPackedTlvHCI_ANumCmmplete_d_Pkt_Event*void * pCtx, tBtampTLVHCI_CNumCmmplete_d_Pkt_Event**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
 //   while ( pTlv->present )
    {
        *pnNeeded += 1;
        *pnNeeded += 2;
        spnNeeded += 2;
 #if 0 // New         *pnNeeded += 2;
        spnNeeded += 2;
        spnNeeded += 2;
        spnNeeded += 2;
        spnNeeded += 2;
        spnNeeded += 2;
 / End iof New  endif

//   w   sreak;
    }
    return status;
} /* End btampGetPackedTLVHCI_CNumCmmplete_d_Pkt_Event* */

t_U32_t btampGetPackedTlvHCI_ANumCmmplete_d_ata_Block__Event*void * pCtx, tBtampTLVHCI_CNumCmmplete_d_ata_Block__Event**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
 //   while ( pTlv->present )
    {
        *pnNeeded += 1;
        *pnNeeded += 4;
        *pnNeeded += 2;
        spnNeeded += 2;
        spnNeeded += 2;
 / E  w   sreak;
    }
    return status;
} /* End btampGetPackedTLVHCI_CNumCmmplete_d_ata_Block__Event* */

t//ypedef v_U32_t (*pfnPackSizeTlvHCI_CNumCmmplete_d_Pkt_Event*t)(poid *, tBtampTLVHCI_Chmmand_Ctatus_Event*  v_U32_t*);
#//define SigPackSizeTlvHCI_CNumCmmplete_d_Pkt_Event** 0x00468)

v_U32_t btampGetPackedTlvHCI_Ceneric_AMP_Link_Key_Notification_Event*void * pCtx, tBtampTLVHCI_Ceneric_AMP_Link_Key_Notification_Event**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 16
        spnNeeded += 23;
        *pnNeeded += 4;
        *reak;
    }
    return status;
} /* End btampGetPackedTLVHCI_Aeneric_AMP_Link_Key_Notification_Event* */

typedef v_U32_t (*pfnPackSizeTlvHCI_Ceneric_AMP_Link_Key_Notification_Event*t)(poid *, tBtampTLVHCI_Ceneric_AMP_Link_Key_Notification_Event*  v_U32_t*);
#define SigPackSizeTlvHCI_Ceneric_AMP_Link_Key_Notification_Event** 0x0045 )

v_U32_t btampGetPackedTlvHCI_AHardwar_EvrrorEvent*void * pCtx, tBtampTLVHCI_CHardwar_EvrrorEvent**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        *reak;
    }
    return status;
} /* End btampGetPackedTLVHCI_AHardwar_EvrrorEvent* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CHardwar_EvrrorEvent*t)(poid *, tBtampTLVHCI_CHardwar_EvrrorEvent*  v_U32_t*);
#define SigPackSizeTlvHCI_CHardwar_EvrrorEvent** 0x0045 )

v_U32_t btampGetPackedTlvHCI_Cogical_Link_Cmnce lCmd*void * pCtx, tBtampTLVHCI_Cogical_Link_Cmnce lCmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        *pnNeeded += 1;
        *reak;
    }
    return status;
} /* End btampGetPackedTLVHCI_Aogical_Link_Cmnce lCmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_Cogical_Link_Cmnce lCmd*t)(poid *, tBtampTLVHCI_Cogical_Link_Cmnce lCmd*  v_U32_t*);
#define SigPackSizeTlvHCI_Cogical_Link_Cmnce lCmd** 0x0045 )

v_U32_t btampGetPackedTlvHCI_Cogical_Link_Cmmplete_Event(void * pCtx, tBtampTLVHCI_Cogical_Link_Cmmplete_Event(*pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        *pnNeeded += 2;
        *pnNeeded += 4;
        *pnNeeded += 1;
        *reak;
    }
    return status;
} /* End btampGetPackedTLVHCI_Aogical_Link_Cmmplete_Event( */

typedef v_U32_t (*pfnPackSizeTlvHCI_Cogical_Link_Cmmplete_Event_t)(poid *, tBtampTLVHCI_Cogical_Link_Complete_Event*  v_U32_t*);
#define SigPackSizeTlvHCI_Cogical_Link_Cmmplete_Event * 0x00457)

v_U32_t btampGetPackedTlvHCI_Coopback_Mhmmand_Cvent(void * pCtx, tBtampTLVHCI_Cogpback_Mhmmand_Cvent(*pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 16;
        break;
    }
    return status;
} /* End btampGetPackedTLVFCI_Cogpback_Mhmmand_Cvent( */

typedef v_U32_t (*pfnPackSizeTlvHCI_Cogpback_Mhmmand_Cvent(t)(poid *, tBtampTLVHCI_Cogpback_Mhmmand_Cvent(  v_U32_t*);
#define SigPackSizeTlvHCI_Cogpback_Mhmmand_Cvent(* 0x00458)

v_U32_t btampGetPackedTlvHCI_Chysical_Link_Cmmplete_Event(void * pCtx, tBtampTLVHCI_Chysical_Link_Cmmplete_Event(*pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        *pnNeeded += 2;
        *reak;
    }
    return status;
} /* End btampGetPackedTLVFCI_Chysical_Link_Cmmplete_Event( */

typedef v_U32_t (*pfnPackSizeTlvHCI_Chysical_Link_Complete_Event_t)(poid *, tBtampTLVHCI_Chysical_Link_Cmmplete_Event*  v_U32_t*);
#define SigPackSizeTlvHCI_Chysical_Link_Cmmplete_Event(* 0x00459)

v_U32_t btampGetPackedTlvHCI_Chysical_Link_CLoss_Waring lvent(void * pCtx, tBtampTLVHCI_Chysical_Link_CLoss_Waring lvent(*pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        *pnNeeded += 2;
        *reak;
    }
    return status;
} /* End btampGetPackedTLVFCI_Chysical_Link_CLoss_Waring lvent( */

typedef v_U32_t (*pfnPackSizeTlvHCI_Chysical_Link_CLoss_Waring lvent(t)(poid *, tBtampTLVHCI_Chysical_Link_CLoss_Waring lvent(  v_U32_t*);
#define SigPackSizeTlvHCI_Chysical_Link_CLoss_Waring lvent(* 0x0045a)

v_U32_t btampGetPackedTlvHCI_Chysical_Link_CRecver ylvent(void * pCtx, tBtampTLVHCI_Chysical_Link_CRecver ylvent(*pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        *reak;
    }
    return status;
} /* End btampGetPackedTLVFCI_Chysical_Link_CRecver ylvent( */

typedef v_U32_t (*pfnPackSizeTlvHCI_Chysical_Link_CRecver ylvent(t)(poid *, tBtampTLVHCI_Chysical_Link_CRecver ylvent(  v_U32_t*);
#define SigPackSizeTlvHCI_Chysical_Link_CRecver ylvent(* 0x0045b)

v_U32_t btampGetPackedTlvHCI_CQos_Violtion_Event*void * pCtx, tBtampTLVHCI_CQos_Violtion_Event**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        sreak;
    }
    return status;
} /* End btampGetPackedTLVHCI_CQos_Violtion_Event* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CQos_Violtion_Event*t)(poid *, tBtampTLVHCI_CQos_Violtion_Event*  v_U32_t*);
#define SigPackSizeTlvHCI_CQos_Violtion_Event** 0x0045c)

v_U32_t btampGetPackedTlvHCI_CSad_Lest_Effort_Flush_Timeout_Cmd*void * pCtx, tBtampTLVHCI_CSad_Lest_Effort_Flush_Timeout_Cmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        sreak;
    }
    return status;
} /* End btampGetPackedTLVHCI_CSad_Lest_Effort_Flush_Timeout_Cmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CSad_Lest_Effort_Flush_Timeout_Cmd*t)(poid *, tBtampTLVHCI_CSad_Lest_Effort_Flush_Timeout_Cmd*  v_U32_t*);
#define SigPackSizeTlvHCI_CSad_Lest_Effort_Flush_Timeout_Cmd** 0x0045d)

v_U32_t btampGetPackedTlvHCI_CSad_Leffer_OizeTCmd*void * pCtx, tBtampTLVHCI_CSad_Leffer_OizeTCmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *reak;
    }
    return status;
} /* End btampGetPackedTLVHCI_CSad_Leffer_OizeTCmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CSad_Leffer_OizeTCmd*t)(poid *, tBtampTLVHCI_CSad_Leffer_OizeTCmd*  v_U32_t*);
#define SigPackSizeTlvHCI_CSad_Leffer_OizeTCmd** 0x0045 )

v_U32_t btampGetPackedTlvACI_CSad_Lonnection_Accept_Timeout_Cmd*void * pCtx, tBtampTLVHCI_CSad_Lonnection_Accept_Timeout_Cmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *reak;
    }
    return status;
} /* End btampGetPackedTLVHCI_CSad_Lonnection_Accept_Timeout_Cmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CSad_Lonnection_Accept_Timeout_Cmd_t)(poid *, tBtampTLVHCI_CSad_Lonnection_Accept_Timeout_Cmd*  v_U32_t*);
#define SigPackSizeTlvHCI_CSad_Lonnection_Accept_Timeout_Cmd** 0x0045 )

v_U32_t btampGetPackedTlvACI_CSad_Lata_Block_OizeTCmd*void * pCtx, tBtampTLVHCI_CSad_Lata_Block_OizeTCmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *reak;
    }
    return status;
} /* End btampGetPackedTLVHCI_CSad_Lata_Block_OizeTCmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CSad_Lata_Block_OizeTCmd*t)(poid *, tBtampTLVHCI_CSad_Lata_Block_OizeTCmd*  v_U32_t*);
#define SigPackSizeTlvHCI_CSad_Lata_Block_OizeTCmd** 0x0046 )

v_U32_t btampGetPackedTlvACI_CSad_LFale _Lonntac_Cmountr_Omd*void * pCtx, tBtampTLVHCI_CSad_LFale _Lonntac_Cmountr_Omd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        sreak;
    }
    return status;
} /* End btampGetPackedTLVHCI_CSad_LFale _Lonntac_Cmountr_Omd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CSad_LFale _Lonntac_Cmountr_Omd*t)(poid *, tBtampTLVHCI_CSad_LFale _Lonntac_Cmountr_Omd*  v_U32_t*);
#define SigPackSizeTlvHCI_CSad_LFale _Lonntac_Cmountr_Omd** 0x0046 )

v_U32_t btampGetPackedTlvACI_CSad_LFow_Control_Mode_Cmd*void * pCtx, tBtampTLVHCI_CSad_LFow_Control_Mode_Cmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *reak;
    }
    return status;
} /* End btampGetPackedTLVHCI_CSad_LFow_Control_Mode_Cmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CSad_LFow_Control_Mode_Cmd_t)(poid *, tBtampTLVHCI_CSad_LFow_Control_Mode_Cmd*  v_U32_t*);
#define SigPackSizeTlvHCI_CSad_LFow_Control_Mode_Cmd** 0x0046 )

v_U32_t btampGetPackedTlvFCI_CSad_Lonk_CQualit_Cmd*void * pCtx, tBtampTLVHCI_CSad_Lonk_CQualit_Cmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        sreak;
    }
    return status;
} /* End btampGetPackedTLVHCI_CSad_Lonk_CQualit_Cmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CSad_Lonk_CQualit_Cmd*t)(poid *, tBtampTLVHCI_CSad_Lonk_CQualit_Cmd*  v_U32_t*);
#define SigPackSizeTlvHCI_CSad_Lonk_CQualit_Cmd** 0x0046 )

v_U32_t btampGetPackedTlvHCI_ASad_Lonk_Cupervision_Timeout_Cmd*void * pCtx, tBtampTLVHCI_CSad_Lonk_Cupervision_Timeout_Cmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        sreak;
    }
    return status;
} /* End btampGetPackedTLVHCI_CSad_Lonk_Cupervision_Timeout_Cmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CSad_Lonk_Cupervision_Timeout_Cmd*t)(poid *, tBtampTLVHCI_CSad_Lonk_Cupervision_Timeout_Cmd*  v_U32_t*);
#define SigPackSizeTlvHCI_CSad_Lonk_Cupervision_Timeout_Cmd** 0x0046 )

v_U32_t btampGetPackedTlvHCI_ASad_Local_AMP_Assoc_Cmd*void * pCtx, tBtampTLVHCI_CSad_Local_AMP_Assoc_Cmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 1;
        *pnNeeded += 2;
        *pnNeeded += 2;
        break;
    }
    return status;
} /* End btampGetPackedTLVACI_CSad_Local_AMP_Assoc_Cmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CSad_Local_AMP_Assoc_Cmd*t)(poid *, tBtampTLVHCI_CSad_Local_AMP_Assoc_Cmd*  v_U32_t*);
#define SigPackSizeTlvHCI_CSad_Local_AMP_Assoc_Cmd** 0x0046 )

v_U32_t btampGetPackedTlvHCI_CSad_Local_AMP_AInformtion_Emd*void * pCtx, tBtampTLVHCI_CSad_Local_AMP_AInformtion_Emd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *reak;
    }
    return status;
} /* End btampGetPackedTLVACI_CSad_Local_AMP_AInformtion_Emd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CSad_Local_AMP_AInformtion_Emd*t)(poid *, tBtampTLVHCI_CSad_Local_AMP_AInformtion_Emd*  v_U32_t*);
#define SigPackSizeTlvHCI_CSad_Local_AMP_AInformtion_Emd** 0x0046 )

v_U32_t btampGetPackedTlvHCI_CSad_Local_Aupepored_ChmdsEmd*void * pCtx, tBtampTLVHCI_CSad_Local_Aupepored_ChmdsEmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *reak;
    }
    return status;
} /* End btampGetPackedTLVACI_CSad_Local_Aupepored_ChmdsEmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CSad_Local_Aupepored_ChmdsEmd*t)(poid *, tBtampTLVHCI_CSad_Local_Aupepored_ChmdsEmd*  v_U32_t*);
#define SigPackSizeTlvHCI_CSad_Local_Aupepored_ChmdsEmd** 0x00467)

v_U32_t btampGetPackedTlvHCI_CSad_Local_Aersion_tInfoEmd*void * pCtx, tBtampTLVHCI_CSad_Local_Aersion_tInfoEmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *reak;
    }
    return status;
} /* End btampGetPackedTLVACI_CSad_Local_Aersion_tInfoEmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CSad_Local_Aersion_tInfoEmd*t)(poid *, tBtampTLVHCI_CSad_Local_Aersion_tInfoEmd*  v_U32_t*);
#define SigPackSizeTlvHCI_CSad_Local_Aersion_tInfoEmd** 0x00468)

v_U32_t btampGetPackedTlvHCI_CSad_Localion_Eata_Bmd*void * pCtx, tBtampTLVHCI_CSad_Localion_Eata_Bmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *reak;
    }
    return status;
} /* End btampGetPackedTLVACI_CSad_Localion_Eata_Bmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CSad_Localion_Eata_Bmd*t)(poid *, tBtampTLVHCI_CSad_Localion_Eata_Bmd*  v_U32_t*);
#define SigPackSizeTlvHCI_CSad_Localion_Eata_Bmd** 0x00469)

v_U32_t btampGetPackedTlvHCI_CSad_Locical_Link_Cccept_Timeout_Cmd*void * pCtx, tBtampTLVHCI_CSad_Locical_Link_Cccept_Timeout_Cmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *reak;
    }
    return status;
} /* End btampGetPackedTLVACI_CSad_Locical_Link_Cccept_Timeout_Cmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CSad_Locical_Link_Cccept_Timeout_Cmd*t)(poid *, tBtampTLVHCI_CSad_Locical_Link_Cccept_Timeout_Cmd*  v_U32_t*);
#define SigPackSizeTlvHCI_CSad_Locical_Link_Cccept_Timeout_Cmd** 0x0046a)

v_U32_t btampGetPackedTlvHCI_CSad_Locpback_Mode_Cmd*void * pCtx, tBtampTLVHCI_CSad_Locpback_Mode_Cmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *reak;
    }
    return status;
} /* End btampGetPackedTLVACI_CSad_Locpback_Mode_Cmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CSad_Locpback_Mode_Cmd*t)(poid *, tBtampTLVHCI_CSad_Locpback_Mode_Cmd*  v_U32_t*);
#define SigPackSizeTlvHCI_CSad_Locpback_Mode_Cmd** 0x0046b)

v_U32_t btampGetPackedTlvHCI_CSad_LRSSICmd*void * pCtx, tBtampTLVHCI_CSad_LRSSICmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 2;
        break;
    }
    return status;
} /* End btampGetPackedTLVACI_CSad_LRSSICmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CSad_LRSSICmd*t)(poid *, tBtampTLVHCI_CSad_LRSSICmd*  v_U32_t*);
#define SigPackSizeTlvHCI_CSad_LRSSICmd** 0x0046c)

v_U32_t btampGetPackedTlvHCI_CSase_Cmd*void * pCtx, tBtampTLVHCI_CSase_Cmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *reak;
    }
    return status;
} /* End btampGetPackedTLVACI_CSase_Cmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CSase_Cmd*t)(poid *, tBtampTLVHCI_CSase_Cmd*  v_U32_t*);
#define SigPackSizeTlvHCI_CSase_Cmd** 0x0046d)

v_U32_t btampGetPackedTlvHCI_CSase_CFale _Lonntac_Cmountr_Omd*void * pCtx, tBtampTLVHCI_CSase_CFale _Lonntac_Cmountr_Omd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 2;
        break;
    }
    return status;
} /* End btampGetPackedTLVACI_CSase_CFale _Lonntac_Cmountr_Omd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CSase_CFale _Lonntac_Cmountr_Omd*t)(poid *, tBtampTLVHCI_CSase_CFale _Lonntac_Cmountr_Omd*  v_U32_t*);
#define SigPackSizeTlvHCI_CSase_CFale _Lonntac_Cmountr_Omd** 0x0046 )

v_U32_t btampGetPackedTlvACI_CSe_Cvent*tMas_Cmd(void * pCtx, tBtampTLVHCI_ASe_Cvent*tMas_Cmd(*pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 2;
        break;
    }
    return status;
} /* End btampGetPackedTLVHCI_ASe_Cvent*tMas_Cmd( */

typedef v_U32_t (*pfnPackSizeTlvHCI_CSe_Cvent*tMas_Cmd(t)(poid *, tBtampTLVHCI_CSe_Cvent*tMas_Cmd(  v_U32_t*);
#define SigPackSizeTlvHCI_CSe_Cvent*tMas_Cmd(* 0x0046 )

v_U32_t btampGetPackedTlvACI_CSe_Cvent*tMas_CPage_2Cmd(void * pCtx, tBtampTLVHCI_ASe_Cvent*tMas_CPage_2Cmd(*pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 2;
        break;
    }
    return status;
} /* End btampGetPackedTLVHCI_ASe_Cvent*tMas_CPage_2Cmd( */

typedef v_U32_t (*pfnPackSizeTlvHCI_CSe_Cvent*tMas_CPage_2Cmd(t)(poid *, tBtampTLVHCI_CSe_Cvent*tMas_CPage_2Cmd(  v_U32_t*);
#define SigPackSizeTlvHCI_CSe_Cvent*tMas_CPage_2Cmd(* 0x0047 )

v_U32_t btampGetPackedTlvACI_CSe_CShrt_FRange_ode_Cmd*void * pCtx, tBtampTLVHCI_CSe_CShrt_FRange_ode_Cmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 2;
        *pnNeeded += 2;
        *reak;
    }
    return status;
} /* End btampGetPackedTLVFCI_CSe_CShrt_FRange_ode_Cmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CSe_CShrt_FRange_ode_Cmd*t)(poid *, tBtampTLVHCI_CSe_CShrt_FRange_ode_Cmd*  v_U32_t*);
#define SigPackSizeTlvHCI_CSe_CShrt_FRange_ode_Cmd** 0x0047 )

v_U32_t btampGetPackedTlvACI_CShrt_FRange_ode_Cmhange_mmplete_Event(void * pCtx, tBtampTLVHCI_CShrt_FRange_ode_Cmhange_mmplete_Event(*pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 2;
        *pnNeeded += 2;
        *pnNeeded += 2;
        *reak;
    }
    return status;
} /* End btampGetPackedTLVFCI_CShrt_FRange_ode_Cmhange_mmplete_Event( */

typedef v_U32_t (*pfnPackSizeTlvHCI_CShrt_FRange_ode_Cmhange_mmplete_Event(t)(poid *, tBtampTLVHCI_CShrt_FRange_ode_Cmhange_mmplete_Event(  v_U32_t*);
#define SigPackSizeTlvHCI_CShrt_FRange_ode_Cmhange_mmplete_Event(* 0x0047 )

v_U32_t btampGetPackedTlvFCI_CWrie_Eest_Effort_Flush_Timeout_Cmd*void * pCtx, tBtampTLVHCI_CWrie_Eest_Effort_Flush_Timeout_Cmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 2;
        *pnNeeded += 2;
        break;
    }
    return status;
} /* End btampGetPackedTLVFCI_CWrie_Eest_Effort_Flush_Timeout_Cmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CWrie_Eest_Effort_Flush_Timeout_Cmd*t)(poid *, tBtampTLVHCI_CWrie_Eest_Effort_Flush_Timeout_Cmd*  v_U32_t*);
#define SigPackSizeTlvHCI_CWrie_Eest_Effort_Flush_Timeout_Cmd** 0x0047 )

v_U32_t btampGetPackedTlvHCI_AWrie_Eonnection_Accept_Timeout_Cmd*void * pCtx, tBtampTLVHCI_CWrie_Eonnection_Accept_Timeout_Cmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 2;
        *reak;
    }
    return status;
} /* End btampGetPackedTLVFCI_CWrie_Eonnection_Accept_Timeout_Cmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CWrie_Eonnection_Accept_Timeout_Cmd*t)(poid *, tBtampTLVHCI_CWrie_Eonnection_Accept_Timeout_Cmd*  v_U32_t*);
#define SigPackSizeTlvHCI_CWrie_Eonnection_Accept_Timeout_Cmd** 0x0047 )

v_U32_t btampGetPackedTlvHCI_AWrie_EFow_Control_Mode_Cmd*void * pCtx, tBtampTLVHCI_CWrie_EFow_Control_Mode_Cmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 2;
        *reak;
    }
    return status;
} /* End btampGetPackedTLVFCI_CWrie_EFow_Control_Mode_Cmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CWrie_EFow_Control_Mode_Cmd_t)(poid *, tBtampTLVHCI_CWrie_EFow_Control_Mode_Cmd_  v_U32_t*);
#define SigPackSizeTlvHCI_CWrie_EFow_Control_Mode_Cmd** 0x0047 )

v_U32_t btampGetPackedTlvHCI_CWrie_Eonk_Cupervision_Timeout_Cmd*void * pCtx, tBtampTLVHCI_CWrie_Eonk_Cupervision_Timeout_Cmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 2;
        *pnNeeded += 2;
        break;
    }
    return status;
} /* End btampGetPackedTLVACI_CWrie_Eonk_Cupervision_Timeout_Cmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CWrie_Eonk_Cupervision_Timeout_Cmd*t)(poid *, tBtampTLVHCI_CWrie_Eonk_Cupervision_Timeout_Cmd*  v_U32_t*);
#define SigPackSizeTlvHCI_CWrie_Eonk_Cupervision_Timeout_Cmd** 0x0047 )

v_U32_t btampGetPackedTlvHCI_CWrie_Eocalion_Eata_Bmd*void * pCtx, tBtampTLVHCI_CWrie_Eocalion_Eata_Bmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 2;
        *pnNeeded += 23
        *pnNeeded += 2;
        *reak;
    }
    return status;
} /* End btampGetPackedTLVFCI_CWrie_Eocalion_Eata_Bmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CWrie_Eocalion_Eata_Bmd*t)(poid *, tBtampTLVHCI_CWrie_Eocalion_Eata_Bmd*  v_U32_t*);
#define SigPackSizeTlvHCI_CWrie_Eocalion_Eata_Bmd** 0x00477)

v_U32_t btampGetPackedTlvHCI_CWrie_Eocical_Link_Cccept_Timeout_Cmd*void * pCtx, tBtampTLVHCI_CWrie_Eocical_Link_Cccept_Timeout_Cmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 2;
        break;
    }
    return status;
} /* End btampGetPackedTLVACI_CWrie_Eocical_Link_Cccept_Timeout_Cmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CWrie_Eocical_Link_Cccept_Timeout_Cmd*t)(poid *, tBtampTLVHCI_CWrie_Eocical_Link_Cccept_Timeout_Cmd*  v_U32_t*);
#define SigPackSizeTlvHCI_CWrie_Eocical_Link_Cccept_Timeout_Cmd** 0x00478)

v_U32_t btampGetPackedTlvHCI_CWrie_Eocpback_Mode_Cmd*void * pCtx, tBtampTLVHCI_CWrie_Eocpback_Mode_Cmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 2;
        *reak;
    }
    return status;
} /* End btampGetPackedTLVFCI_CWrie_Eocpback_Mode_Cmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CWrie_Eocpback_Mode_Cmd*t)(poid *, tBtampTLVHCI_CWrie_Eocpback_Mode_Cmd*  v_U32_t*);
#define SigPackSizeTlvHCI_CWrie_Eocpback_Mode_Cmd** 0x00479)

v_U32_t btampGetPackedTlvHCI_CWrie_ERemoe_EMP_AsSSOCCmd*void * pCtx, tBtampTLVHCI_CWrie_ERemoe_EMP_AsSSOCCmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
 #ifef vWLAN_BAPCI_CENABLE_LOGGING    (VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,       "InbtampGetPackedTlvHCI_CWrie_ERemoe_EMP_AsSSOCCmd*\n");  endif
    
    while ( pTlv->present )
    {
        *pnNeeded += 2;
        *pnNeeded += 2;
        spnNeeded += 2;
        spnNeeded += 2Tlv->pmpG_asoc_Cemaining length;
        break;
    }
    return status;
} /* End btampGetPackedTLVFCI_CWrie_ERemoe_EMP_AsSSOCCmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CWrie_ERemoe_EMP_AsSSOCCmd*t)(poid *, tBtampTLVHCI_CWrie_ERemoe_EMP_AsSSOCCmd*  v_U32_t*);
#define SigPackSizeTlvHCI_CWrie_ERemoe_EMP_AsSSOCCmd** 0x0047a)

v_U32_t btampGetPackedTlvHCI_CEnhnce dClosh_Cmd*void * pCtx, tBtampTLVHCI_CEnhnce dClosh_Cmd**pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 2;
        *pnNeeded += 4;
        *reak;
    }
    return status;
} /* End btampGetPackedTLVHCI_AEnhnce dClosh_Cmd* */

typedef v_U32_t (*pfnPackSizeTlvHCI_CEnhnce dClosh_Cmd*t)(poid *, tBtampTLVHCI_CEnhnce dClosh_Cmd*  v_U32_t*);
#define SigPackSizeTlvHCI_CEnhnce dClosh_Cmd** 0x0047b)

v_U32_t btampGetPackedTlvHCI_CEnhnce dClosh_Cmmplete_Event(void * pCtx, tBtampTLVHCI_CEnhnce dClosh_Cmmplete_Event(*pTlv, v_U32_t *pnNeeded)
{
    v_U32_t status = BTAMP_PARSE_SUCCESS;
    (void)pCtx; (void)pTlv; (void)pnNeeded;
    while ( pTlv->present )
    {
        *pnNeeded += 2;
        *reak;
    }
    return status;
} /* End btampGetPackedTLVHCI_AEnhnce dClosh_Cmmplete_Event( */

typedef v_U32_t (*pfnPackSizeTlvHCI_CEnhnce dClosh_Cmmplete_Event(t)(poid *, tBtampTLVHCI_CEnhnce dClosh_Cmmplete_Event(  v_U32_t*);
#define SigPackSizeTlvHCI_CEnhnce dClosh_Cmmplete_Event(* 0x0047c)

v_U32_t btampGetPackedTMP_AsSSOCizeTvoid * pCtx, tBtampTMP_AsSSOC*pnFrm v_U32_t *pnNeeded)
{
    vtatuic tLVHDefn LVHS[ ]= B
        *{TAMP_PLVHEMP_AsSSOCCMAC_ADDR, 0, 9, 9, offsetof(BtampTMP_AsSSOC, MP_Assoc_CMAC_Addr), offsetof(BtampTLVHMP_Assoc_CMAC_Addr, resent ), igPackSizeTlvHMP_Assoc_CMAC_Addr, (fnPeneric_At)tampGetPackedTlvHMP_Assoc_CMAC_Addr, "MP_Assoc_CMAC_Addr", 1, },        *{TAMP_PLVHEMP_AsSSOCCPREFERRED_CHANNEL_LIST, 0, 9, 12, offsetof(BtampTMP_AsSSOC, MP_Assoc_CPrefered_Emhanne_Linst), offsetof(BtampTLVHMP_Assoc_CPrefered_Emhanne_Linst, resent ), igPackSizeTlvHMP_Assoc_CPrefered_Emhanne_Linst, (fnPeneric_At)tampGetPackedTlvHMP_Assoc_CPrefered_Emhanne_Linst, "MP_Assoc_CPrefered_Emhanne_Linst", 1, },        *{TAMP_PLVHEMP_AsSSOCCCONNECTED_CHANNEL, 0, 9, 12, offsetof(BtampTMP_AsSSOC, MP_Assoc_Connectid_Emhanne_), offsetof(BtampTLVHMP_Assoc_Connectid_Emhanne_, resent ), igPackSizeTlvHMP_Assoc_Connectid_Emhanne_, (fnPeneric_At)tampGetPackedTlvHMP_Assoc_Connectid_Emhanne_, "MP_Assoc_Connectid_Emhanne_", 0, },        *{TAMP_PLVHEMP_AsSSOCCPAL_CAPABILITIES, 0, 7,  7, offsetof(BtampTMP_AsSSOC, MP_Assoc_CPAL_Capabilities), offsetof(BtampTLVHMP_Assoc_CPAL_Capabilities, resent ), igPackSizeTlvHMP_Assoc_CPAL_Capabilities, (fnPeneric_At)tampGetPackedTlvHMP_Assoc_CPAL_Capabilities, "MP_Assoc_CPAL_Capabilities", 0, },        *{TAMP_PLVHEMP_AsSSOCCPAL_VERSION, 0, 8, 8, offsetof(BtampTMP_AsSSOC, MP_Assoc_CPAL_ersion_), offsetof(BtampTLVHMP_Assoc_CPAL_ersion_, resent ), igPackSizeTlvHMP_Assoc_CPAL_ersion_, (fnPeneric_At)tampGetPackedTlvHMP_Assoc_CPAL_ersion_, "MP_Assoc_CPAL_ersion_", 1, },     {0x0ffff, 0 },     };
    v_U32_t status = B0
    }pnNeeded + B0
 #ifef vWLAN_BAPCI_CENABLE_LOGGING    (VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,       "InbtampGetPackedTMP_AsSSOCizeT\n");  endif
    
    wtatus =|= etPackedTizeTlvHCore(Ctx, (_U38t*);nFrm nNeeded ,LVHS);    return status;
} /* End btampGetPackedTMP_AsSSOCizeT */

ttatuic _U32_t setPackedTizeTlvHCore(oid * pCtx,         **************************_U38t**pnFrm         **************************_U32_t *pnNeeded)         **************************tLVHDefn  LVHs[]
{
    vtLVHDefn     }pnlv;     v_U32_t sstatus;,status;;
     tFRAMES_BOOL}pnfFound;
    wtatus = BTAMP_PARSE_SUCCESS;
    (tatus;;= BTAMP_PARSE_SUCCESS;
 #ifef vWLAN_BAPCI_CENABLE_LOGGING    (VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,       "InbetPackedTizeTlvHCore\n");  endif
    
    wnlv;= B&( LVHs[0] )
    while ( px0ffff ! 2Tlv->pid)
    {
        *nfFound= B(tFRAMES_BOOL*)(nFrm +2Tlv->poffset +        **************************pTlv->presentceOffset)
        *f
 (}pnfFound)
    {   {
        *   }pnNeeded += 2;U;        *   }f
 (}Tlv->prec)
*pnNeeded += 23U
 #ifef vWLAN_BAPCI_CENABLE_LOGGING    (((((((((VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,               "InbetPackedTizeTlvHCore,}Tlv->psig - %*\n",}Tlv->psig);  endif

             switch (flv->psig)             {        *********cas SigPackSizeTlvHMP_Assoc_Connectid_Emhanne_:        *****************tatus;;= B( (fnPackSizeTlvHMP_Assoc_Connectid_Emhanne_t)(pTlv->prfn) )(Ctx, B( BtampTLVHMP_Assoc_Connectid_Emhanne_* )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHMP_Assoc_CMAC_Addr:        *****************tatus;;= B( (fnPackSizeTlvHMP_Assoc_CMAC_Addrt)(pTlv->prfn) )(Ctx, B( BtampTLVHMP_Assoc_CMAC_Addr* )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHMP_Assoc_CPAL_Capabilities:        *****************tatus;;= B( (fnPackSizeTlvHMP_Assoc_CPAL_Capabilitiest)(pTlv->prfn) )(Ctx, B( BtampTLVHMP_Assoc_CPAL_Capabilities* )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHMP_Assoc_CPAL_ersion_:        *****************tatus;;= B( (fnPackSizeTlvHMP_Assoc_CPAL_ersion_t)(pTlv->prfn) )(Ctx, B( BtampTLVHMP_Assoc_CPAL_ersion_* )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHMP_Assoc_CPrefered_Emhanne_Linst:        *****************tatus;;= B( (fnPackSizeTlvHMP_Assoc_CPrefered_Emhanne_Linstt)(pTlv->prfn) )(Ctx, B( BtampTLVHMP_Assoc_CPrefered_Emhanne_Linst* )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHlow_Spec_:        *****************tatus;;= B( (fnPackSizeTlvHlow_Spec_M)(pTlv->prfn) )(Ctx, B( BtampTLVHlow_Spec_* )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_Cccept_Togical_Link_Cmmd:        *****************tatus;;= B( (fnPackSizeTlvHCI_Cccept_Togical_Link_CmmdM)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_Cccept_Togical_Link_Cmmd* )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_Cccept_Thysical_Link_Cmmd:        *****************tatus;;= B( (fnPackSizeTlvHCI_Cccept_Thysical_Link_CmmdM)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_Cccept_Thysical_Link_Cmmd* )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_Cmhanne_LSelctid_Event(:        *****************tatus;;= B( (fnPackSizeTlvHCI_Cmhanne_LSelctid_Event(M)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_Cmhanne_LSelctid_Event(* )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_Cmmmand_Cmmplete_Event(:        *****************tatus;;= B( (fnPackSizeTlvHCI_Cmmmand_Cmmplete_Event(M)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_Cmmmand_Cmmplete_Event(* )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_Cmmmand_CSatus;Event(:        *****************tatus;;= B( (fnPackSizeTlvHCI_Cmmmand_CSatus;Event(M)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_Cmmmand_CSatus;Event(* )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_Cmeake_Eocical_Link_Cmmd:        *****************tatus;;= B( (fnPackSizeTlvHCI_Cmeake_Eocical_Link_CmmdM)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_Cmeake_Eocical_Link_Cmmd* )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_Cmeake_Ehysical_Link_Cmmd:        *****************tatus;;= B( (fnPackSizeTlvHCI_Cmeake_Ehysical_Link_CmmdM)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_Cmeake_Ehysical_Link_Cmmd* )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_Cata_Blffer_OOverfow_Svent(:        *****************tatus;;= B( (fnPackSizeTlvHCI_Cata_Blffer_OOverfow_Svent(M)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_Cata_Blffer_OOverfow_Svent(* )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CaiscnnectiEocical_Link_Cmmd:        *****************tatus;;= B( (fnPackSizeTlvHCI_CaiscnnectiEocical_Link_CmmdM)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CaiscnnectiEocical_Link_Cmmd* )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CaiscnnectiEocical_Link_Cmmplete_Event(:        *****************tatus;;= B( (fnPackSizeTlvHCI_CaiscnnectiEocical_Link_Cmmplete_Event(M)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CaiscnnectiEocical_Link_Cmmplete_Event(* )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CaiscnnectiEhysical_Link_Cmmd:        *****************tatus;;= B( (fnPackSizeTlvHCI_CaiscnnectiEhysical_Link_CmmdM)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CaiscnnectiEhysical_Link_Cmmd* )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CaiscnnectiEhysical_Link_Cmmplete_Event(:        *****************tatus;;= B( (fnPackSizeTlvHCI_CaiscnnectiEhysical_Link_Complete_Event_t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CaiscnnectiEhysical_Link_Cmmplete_Event(* )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_Clow_Spec_MModifyCmmd:        *****************tatus;;= B( (fnPackSizeTlvHCI_Clow_Spec_MModifyCmmdt)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_Clow_Spec_MModifyCmmd* )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_Clow_Spec_MModifyCmmplete_Event(:        *****************tatus;;= B( (fnPackSizeTlvHCI_Clow_Spec_MModifyCmmplete_Event(t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_Clow_Spec_MModifyCmmplete_Event(* )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_Closh_Cmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_Closh_Cmd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_Closh_Cmd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_Closh_COccured_Event(:        *****************tatus;;= B( (fnPackSizeTlvHCI_Closh_COccured_Event(t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_Closh_COccured_Event(  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_Ceneric_AMP_Aink_CKey_Notifiction_Event*:        *****************tatus;;= B( (fnPackSizeTlvHCI_Ceneric_AMP_Aink_CKey_Notifiction_Event*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_Ceneric_AMP_Aink_CKey_Notifiction_Event*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CHardwar_EvrrorEvent*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CHardwar_EvrrorEvent*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CHardwar_EvrrorEvent*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_Cocical_Link_Cmnce lCmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_Cocical_Link_Cmnce lCmd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_Cocical_Link_Cmnce lCmd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_Cocical_Link_Cmmplete_Event(:        *****************tatus;;= B( (fnPackSizeTlvHCI_Cocical_Link_Cmmplete_Event(M)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_Cocical_Link_Cmmplete_Event(* )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_Cocpback_Mmmmand_Cvent(:        *****************tatus;;= B( (fnPackSizeTlvHCI_Cocpback_Mmmmand_Cvent(M)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_Cocpback_Mmmmand_Cvent(* )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_Chysical_Link_Cmmplete_Event(:        *****************tatus;;= B( (fnPackSizeTlvHCI_Chysical_Link_Complete_Event_t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_Chysical_Link_Cmmplete_Event(* )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_Chysical_Link_CLoss_Waring lvent(:        *****************tatus;;= B( (fnPackSizeTlvHCI_Chysical_Link_CLoss_Waring lvent(t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_Chysical_Link_CLoss_Waring lvent(  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_Chysical_Link_CRecver ylvent(:        *****************tatus;;= B( (fnPackSizeTlvHCI_Chysical_Link_CRecver ylvent(t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_Chysical_Link_CRecver ylvent(  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CQos_Violtion_Event*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CQos_Violtion_Event*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CQos_Violtion_Event*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CRad_Lest_Effort_Flush_Timeout_Cmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CRad_Lest_Effort_Flush_Timeout_Cmd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CRad_Lest_Effort_Flush_Timeout_Cmd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CRad_Leffer_OizeTCmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CRad_Leffer_OizeTCmd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CRad_Leffer_OizeTCmd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CRad_Lonnection_Accept_Timeout_Cmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CRad_Lonnection_Accept_Timeout_Cmd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CRad_Lonnection_Accept_Timeout_Cmd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CRad_Lata_Block_OizeTCmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CRad_Lata_Block_OizeTCmd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CRad_Lata_Block_OizeTCmd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CRad_LFale _Lonntac_Cmountr_Omd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CRad_LFale _Lonntac_Cmountr_Omd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CRad_LFale _Lonntac_Cmountr_Omd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CRad_LFow_Control_Mode_Cmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CRad_LFow_Control_Mode_Cmd_t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CRad_LFow_Control_Mode_Cmd_  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CRad_Lonk_CQualit_Cmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CRad_Lonk_CQualit_Cmd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CRad_Lonk_CQualit_Cmd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CRad_Lonk_Cupervision_Timeout_Cmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CRad_Lonk_Cupervision_Timeout_Cmd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CRad_Lonk_Cupervision_Timeout_Cmd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CRad_Local_AMP_Assoc_Cmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CRad_Local_AMP_Assoc_Cmd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CRad_Local_AMP_Assoc_Cmd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CRad_Local_AMP_AInformtion_Emd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CRad_Local_AMP_AInformtion_Emd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CRad_Local_AMP_AInformtion_Emd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CRad_Local_Aupepored_ChmdsEmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CRad_Local_Aupepored_ChmdsEmd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CRad_Local_Aupepored_ChmdsEmd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CRad_Local_Aersion_tInfoEmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CRad_Local_Aersion_tInfoEmd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CRad_Local_Aersion_tInfoEmd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CRad_Localion_Eata_Bmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CRad_Localion_Eata_Bmd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CRad_Localion_Eata_Bmd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CRad_Locical_Link_Cccept_Timeout_Cmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CRad_Locical_Link_Cccept_Timeout_Cmd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CRad_Locical_Link_Cccept_Timeout_Cmd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CRad_Locpback_Mode_Cmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CRad_Locpback_Mode_Cmd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CRad_Locpback_Mode_Cmd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CRad_LRSSICmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CRad_LRSSICmd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CRad_LRSSICmd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CRase_Cmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CRase_Cmd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CRase_Cmd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CRase_CFale _Lonntac_Cmountr_Omd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CRase_CFale _Lonntac_Cmountr_Omd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CRase_CFale _Lonntac_Cmountr_Omd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CSe_Cvent*tMas_Cmd(:        *****************tatus;;= B( (fnPackSizeTlvHCI_CSe_Cvent*tMas_Cmd(t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CSe_Cvent*tMas_Cmd(  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CSe_Cvent*tMas_CPage_2Cmd(:        *****************tatus;;= B( (fnPackSizeTlvHCI_CSe_Cvent*tMas_CPage_2Cmd(t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CSe_Cvent*tMas_CPage_2Cmd(  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CSe_CShrt_FRange_ode_Cmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CSe_CShrt_FRange_ode_Cmd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CSe_CShrt_FRange_ode_Cmd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CShrt_FRange_ode_Cmhange_mmplete_Event(:        *****************tatus;;= B( (fnPackSizeTlvHCI_CShrt_FRange_ode_Cmhange_mmplete_Event(t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CShrt_FRange_ode_Cmhange_mmplete_Event(  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CWrie_Eest_Effort_Flush_Timeout_Cmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CWrie_Eest_Effort_Flush_Timeout_Cmd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CWrie_Eest_Effort_Flush_Timeout_Cmd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CWrie_Eonnection_Accept_Timeout_Cmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CWrie_Eonnection_Accept_Timeout_Cmd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CWrie_Eonnection_Accept_Timeout_Cmd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CWrie_EFow_Control_Mode_Cmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CWrie_EFow_Control_Mode_Cmd_t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CWrie_EFow_Control_Mode_Cmd_  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CWrie_Eonk_Cupervision_Timeout_Cmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CWrie_Eonk_Cupervision_Timeout_Cmd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CWrie_Eonk_Cupervision_Timeout_Cmd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CWrie_Eocalion_Eata_Bmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CWrie_Eocalion_Eata_Bmd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CWrie_Eocalion_Eata_Bmd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CWrie_Eocical_Link_Cccept_Timeout_Cmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CWrie_Eocical_Link_Cccept_Timeout_Cmd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CWrie_Eocical_Link_Cccept_Timeout_Cmd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CWrie_Eocpback_Mode_Cmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CWrie_Eocpback_Mode_Cmd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CWrie_Eocpback_Mode_Cmd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *********cas SigPackSizeTlvHCI_CWrie_ERemoe_EMP_AsSSOCCmd*:        *****************tatus;;= B( (fnPackSizeTlvHCI_CWrie_ERemoe_EMP_AsSSOCCmd*t)(pTlv->prfn) )(Ctx, B( BtampTLVHCI_CWrie_ERemoe_EMP_AsSSOCCmd*  )(nFrm +2Tlv->poffset), nNeeded)
;        *****************f
 (tatus;;)wtatus =|= tatus;;
                     reak;
    }   *****defaul(:        *********FRAMES_LOG1(Ctx, BFRLOGE BFRFL("INTERNAL ERROR-- I don"                     "'t know abut_ the LVH signtusre %d; this is most l"                     "ikely a bug in 'framesc'.\n"),}Tlv->psig);                 eturn sTAMP_PINTERNAL_ERROR;             }
        }
        ++Tlv-;     
    return status;
} v_U32_t btampGackSTvHMP_Assoc_Connectid_Emhanne_(oid * pCtx,         *****************************************BtampTLVHMP_Assoc_Connectid_Emhanne_ *pSrc         *****************************************_U38t**pnBuf         *****************************************_U32_t bnBuf         *****************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B;
     tLen= B2
 #ifef vWLAN_BAPCI_CENABLE_LOGGING    (VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,       "InbtampGackSTvHMP_Assoc_Connectid_Emhanne_\n");  endif
    
    // sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
      nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHMP_Assoc_Connectid_Emhanne_(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  3, 0);         els S*nBuf =23
        *nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         TAMP_PMEMCPY(Ctx, tnBuf  TSrc>pcountry  3);         *pnonnsumd) = 23
        *nBuf = 23
        *nBuf - 23
        *f
 (}TSrc>pnum_trilete =)        
        *    TAMP_PMEMCPY(Ctx, tnBuf  &(}TSrc>ptrilete =), (}TSrc>pnum_trilete =* 3 ));             *pnonnsumd) = 2(}TSrc>pnum_trilete =* 3 );             nBuf = 2(2(}TSrc>pnum_trilete =* 3 ) );             nBuf - 2(2(}TSrc>pnum_trilete =* 3 ) );         }         els Sreak;
    }   *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } 
    els Sif(NULL ! 2Tlv-Len
    {
        *pnlv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHMP_Assoc_Connectid_Emhanne_ */

typedef v_U32_t (*pfnPackSTvHMP_Assoc_Connectid_Emhanne_t)(poid *, tBtampTLVHMP_Assoc_Connectid_Emhanne_ *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHMP_Assoc_Connectid_Emhanne_  0x0047b)

v_U32_t btampGackSTvHMP_Assoc_CMAC_Addr(oid * pCtx,         ********************************BtampTLVHMP_Assoc_CMAC_Addr *pSrc         ********************************_U38t**pnBuf         ********************************_U32_t bnBuf         ********************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B;
     tLen= B2
 #ifef vWLAN_BAPCI_CENABLE_LOGGING    (VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,       "InbtampGackSTvHMP_Assoc_CMAC_Addr\n");  endif
    
    // sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
      nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHMP_Assoc_CMAC_Addr(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  1, 0);         els S*nBuf =21
        *nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         TAMP_PMEMCPY(Ctx, tnBuf  TSrc>pmac_addr, 6);         *pnonnsumd) = 26;        *nBuf = 26;        *nBuf - 26
    }   *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        *pnlv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHMP_Assoc_CMAC_Addr */

typedef v_U32_t (*pfnPackSTvHMP_Assoc_CMAC_Addrt)(poid *, tBtampTLVHMP_Assoc_CMAC_Addr *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHMP_Assoc_CMAC_Addr  0x0047c)

v_U32_t btampGackSTvHMP_Assoc_CPAL_Capabilities(oid * pCtx,         ****************************************BtampTLVHMP_Assoc_CPAL_Capabilities *pSrc         ****************************************_U38t**pnBuf         ****************************************_U32_t bnBuf         ****************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B;
     tLen= B2
 #ifef vWLAN_BAPCI_CENABLE_LOGGING    (VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,       "InbtampGackSTvHMP_Assoc_CPAL_Capabilities\n");  endif
    
    // sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
      nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHMP_Assoc_CPAL_Capabilities(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  4, 0);         els S*nBuf =24
        *nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         frameshtnnl(Ctx, tnBuf  TSrc>ppal_capabilities, 0);         *pnonnsumd) = 24
        *nBuf = 24;        *nBuf - 24
    }   *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        *pnlv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHMP_Assoc_CPAL_Capabilities */

typedef v_U32_t (*pfnPackSTvHMP_Assoc_CPAL_Capabilitiest)(poid *, tBtampTLVHMP_Assoc_CPAL_Capabilities *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHMP_Assoc_CPAL_Capabilities  0x0047d)

v_U32_t btampGackSTvHMP_Assoc_CPAL_ersion_(oid * pCtx,         ***********************************BtampTLVHMP_Assoc_CPAL_ersion_ *pSrc         ***********************************_U38t**pnBuf         ***********************************_U32_t bnBuf         ***********************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B;
     tLen= B2
 #ifef vWLAN_BAPCI_CENABLE_LOGGING    (VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,       "InbtampGackSTvHMP_Assoc_CPAL_ersion_\n");  endif
    
    // sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
      nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHMP_Assoc_CPAL_ersion_(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  5, 0);         els S*nBuf =25
        *nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         *nBuf =2TSrc>ppal_vrsion_;         *pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *frameshtnns(Ctx, tnBuf  TSrc>ppal_mmplanyID, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *frameshtnns(Ctx, tnBuf  TSrc>ppal_subvrsion_, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        *pnlv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHMP_Assoc_CPAL_ersion_ */

typedef v_U32_t (*pfnPackSTvHMP_Assoc_CPAL_ersion_t)(poid *, tBtampTLVHMP_Assoc_CPAL_ersion_ *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHMP_Assoc_CPAL_ersion_  0x0047e)

v_U32_t btampGackSTvHMP_Assoc_CPrefered_Emhanne_Linst(oid * pCtx,         **********************************************BtampTLVHMP_Assoc_CPrefered_Emhanne_Linst *pSrc         **********************************************_U38t**pnBuf         **********************************************_U32_t bnBuf         **********************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B;
     tLen= B2
 #ifef vWLAN_BAPCI_CENABLE_LOGGING    (VOS_TRACE(VOS_MODULE_ID_BAP,VOS_TRACE_LEVEL_ERROR,       "InbtampGackSTvHMP_Assoc_CPrefered_Emhanne_Linst\n");  endif
    
    // sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
      nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHMP_Assoc_CPrefered_Emhanne_Linst(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  2, 0);         els S*nBuf =22
        *nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         TAMP_PMEMCPY(Ctx, tnBuf  TSrc>pcountry  3);         *pnonnsumd) = 23
        *nBuf = 23
        *nBuf - 23
        *f
 (}TSrc>pnum_trilete =)        
        *    TAMP_PMEMCPY(Ctx, tnBuf  &(}TSrc>ptrilete =), (}TSrc>pnum_trilete =* 3 ));             *pnonnsumd) = 2(}TSrc>pnum_trilete =* 3 );             nBuf = 2(2(}TSrc>pnum_trilete =* 3 ) );             nBuf - 2(2(}TSrc>pnum_trilete =* 3 ) );         }         els Sreak;
    }   *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        *pnlv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHMP_Assoc_CPrefered_Emhanne_Linst */

typedef v_U32_t (*pfnPackSTvHMP_Assoc_CPrefered_Emhanne_Linstt)(poid *, tBtampTLVHMP_Assoc_CPrefered_Emhanne_Linst *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHMP_Assoc_CPrefered_Emhanne_Linst  0x0047f)

v_U32_t btampGackSTvHlow_Spec_(oid * pCtx,         ***********************BtampTLVHlow_Spec_ *pSrc         ***********************_U38t**pnBuf         ***********************_U32_t bnBuf         ***********************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B;
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
      nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHlow_Spec_(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  6, 0);         els S*nBuf =26;        *nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         *nBuf =2TSrc>pfow_Ssec_Mid;         *pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        **nBuf =2TSrc>psrvisce_type;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *frameshtnns(Ctx, tnBuf  TSrc>pmax_sdu, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *frameshtnnl(Ctx, tnBuf  TSrc>psdu_intr_Oarrival, 0);         *pnonnsumd) = 24
        *nBuf = 24;        *nBuf - 24
    }   *frameshtnnl(Ctx, tnBuf  TSrc>paccess_latency, 0);         *pnonnsumd) = 24
        *nBuf = 24;        *nBuf - 24
    }   *frameshtnnl(Ctx, tnBuf  TSrc>pfush_Ttmeout_, 0);         *pnonnsumd) = 24
        *nBuf = 24;        *nBuf - 24
    }   *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
     {
        *pnlv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHlow_Spec_ */

typedef v_U32_t (*pfnPackSTvHlow_Spec_M)(poid *, tBtampTLVHlow_Spec_ *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHlow_Spec_  0x00480)

v_U32_t btampGackSTvHCI_Cccept_Togical_Link_Cmmd(oid * pCtx,         *****************************************BtampTLVHCI_Cccept_Togical_Link_Cmmd *pSrc         *****************************************_U38t**pnBuf         *****************************************_U32_t bnBuf         *****************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
      nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_Cccept_Togical_Link_Cmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  1081, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         *nBuf =2TSrc>pphy_lnk_Chandle;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *TAMP_PMEMCPY(Ctx, tnBuf  TSrc>ptx_fow_Ssec_  18);         *pnonnsumd) = 218
        *nBuf = 218;        *nBuf - 218;        *TAMP_PMEMCPY(Ctx, tnBuf  TSrc>prx_fow_Ssec_  18);         *pnonnsumd) = 218
        *nBuf = 218;        *nBuf - 218;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        *pnlv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_Cccept_Togical_Link_Cmmd */

typedef v_U32_t (*pfnPackSTvHCI_Cccept_Togical_Link_CmmdM)(poid *, tBtampTLVHCI_Cccept_Togical_Link_Cmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_Cccept_Togical_Link_Cmmd  0x00481)

v_U32_t btampGackSTvHCI_Cccept_Thysical_Link_Cmmd(oid * pCtx,         ******************************************BtampTLVHCI_Cccept_Thysical_Link_Cmmd *pSrc         ******************************************_U38t**pnBuf         ******************************************_U32_t bnBuf         ******************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
      nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_Cccept_Thysical_Link_Cmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  1078, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         *nBuf =2TSrc>pphy_lnk_Chandle;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        **nBuf =2TSrc>pkey_length;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        **nBuf =2TSrc>pkey_type;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *TAMP_PMEMCPY(Ctx, tnBuf  &(}TSrc>pkey_material=), TSrc>pkey_length);         *pnonnsumd) = 2TSrc>pkey_length;        *nBuf = 2(2TSrc>pkey_length );         nBuf - 2(2TSrc>pkey_length );         reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        *pnlv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_Cccept_Thysical_Link_Cmmd */

typedef v_U32_t (*pfnPackSTvHCI_Cccept_Thysical_Link_CmmdM)(poid *, tBtampTLVHCI_Cccept_Thysical_Link_Cmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_Cccept_Thysical_Link_Cmmd  0x00482)

v_U32_t btampGackSTvHCI_Cmhanne_LSelctid_Event((oid * pCtx,         ****************************************BtampTLVHCI_Cmhanne_LSelctid_Event( *pSrc         ****************************************_U38t**pnBuf         ****************************************_U32_t bnBuf         ****************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B;
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_Cmhanne_LSelctid_Event((Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  65, 0);         els S*nBuf =265
        *nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         *nBuf =2TSrc>pphy_lnk_Chandle;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        *pnlv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_Cmhanne_LSelctid_Event( */

typedef v_U32_t (*pfnPackSTvHCI_Cmhanne_LSelctid_Event(M)(poid *, tBtampTLVHCI_Cmhanne_LSelctid_Event( *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_Cmhanne_LSelctid_Event(  0x00483)

v_U32_t btampGackSTvHCI_Cmmmand_Cmmplete_Event((oid * pCtx,         ****************************************BtampTLVHCI_Cmmmand_Cmmplete_Event( *pSrc         ****************************************_U38t**pnBuf         ****************************************_U32_t bnBuf         ****************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B;
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
      nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_Cmmmand_Cmmplete_Event((Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  14, 0);         els S*nBuf =214
        *nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         *nBuf =2TSrc>pnum_hci_cmmand_Cpckedts;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *frameshtnns(Ctx, tnBuf  TSrc>pcmmand_Copcode, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *switch (nSrc>pcmmand_Copcode)        *
        *****cas S3075:        **********nBuf =2TSrc>pcc_eent( Rase_.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *****reak;
    }   *****cas S3080:        **********nBuf =2TSrc>pcc_eent( lush_.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *********frameshtnns(Ctx, tnBuf  TSrc>pcc_eent( lush_.log_lnk_Chandle, 0);         *********nnonnsumd) = 2;
                 nBuf = 22;        *       *nBuf - 22;        *****reak;
    }   *****cas S1483:        **********nBuf =2TSrc>pcc_eent( ogical_Link_Cmancel.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        **********nBuf =2TSrc>pcc_eent( ogical_Link_Cmancel.phy_lnk_Chandle;        **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        **********nBuf =2TSrc>pcc_eent( ogical_Link_Cmancel.tx_fow_Ssec_Mid;         *********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *****reak;
    }   *****cas S3077:        **********nBuf =2TSrc>pcc_eent( Se_Cvent*tMas_.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *****reak;
    }   *****cas S3093:        **********nBuf =2TSrc>pcc_eent( Rad_LCnnection_Accept_TiO.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *********frameshtnns(Ctx, tnBuf  TSrc>pcc_eent( Rad_LCnnection_Accept_TiO.cnnection_Aacept_Ttmeout_, 0);         *********nnonnsumd) = 2;
                 nBuf = 22;        *       *nBuf - 22;        *****reak;
    }   *****cas S3094:        **********nBuf =2TSrc>pcc_eent( Wrie_Eonnection_Accept_TiO.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *****reak;
    }   *****cas S3126:        **********nBuf =2TSrc>pcc_eent( Rad_Lonk_Cupervision_TiO.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *********frameshtnns(Ctx, tnBuf  TSrc>pcc_eent( Rad_Lonk_Cupervision_TiO.log_lnk_Chandle, 0);         *********nnonnsumd) = 2;
                 nBuf = 22;        *       *nBuf - 22;        *********frameshtnns(Ctx, tnBuf  TSrc>pcc_eent( Rad_Lonk_Cupervision_TiO.lnk_Cspervision_Ttmeout_, 0);         *********nnonnsumd) = 2;
                 nBuf = 22;        *       *nBuf - 22;        *****reak;
    }   *****cas S3127:        **********nBuf =2TSrc>pcc_eent( Wrie_Eonk_Cupervision_TiO.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *********frameshtnns(Ctx, tnBuf  TSrc>pcc_eent( Wrie_Eonk_Cupervision_TiO.log_lnk_Chandle, 0);         *********nnonnsumd) = 2;
                 nBuf = 22;        *       *nBuf - 22;        *****reak;
    }   *****cas S3169:        **********nBuf =2TSrc>pcc_eent( Rad_Locical_Link_Cccept_TiO.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *********frameshtnns(Ctx, tnBuf  TSrc>pcc_eent( Rad_Locical_Link_Cccept_TiO.lcical_Llnk_Cacept_Ttmeout_, 0);         *********nnonnsumd) = 2;
                 nBuf = 22;        *       *nBuf - 22;        *****reak;
    }   *****cas S3170:        **********nBuf =2TSrc>pcc_eent( Wrie_Eocical_Link_Cccept_TiO.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *****reak;
    }   *****cas S3171:        **********nBuf =2TSrc>pcc_eent( Se_Cvent*tMas_CPage_2.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *****reak;
    }   *****cas S3172:        **********nBuf =2TSrc>pcc_eent( Rad_Localion_Eata_.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        **********nBuf =2TSrc>pcc_eent( Rad_Localion_Eata_.loc_domai_Aaware;        **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *********TAMP_PMEMCPY(Ctx, tnBuf  TSrc>pcc_eent( Rad_Localion_Eata_.loc_domai_  3);         *********nnonnsumd) = 23
        *       *nBuf = 23
        *       *nBuf - 23
        **********nBuf =2TSrc>pcc_eent( Rad_Localion_Eata_.loc_opion_;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *****reak;
    }   *****cas S3173:        **********nBuf =2TSrc>pcc_eent( Wrie_Eocalion_Eata_.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *****reak;
    }   *****cas S3174:        **********nBuf =2TSrc>pcc_eent( Rad_LFow_Control_Mode_.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        **********nBuf =2TSrc>pcc_eent( Rad_LFow_Control_Mode_.fow_Scntrol_Mmde_
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *****reak;
    }   *****cas S3175:        **********nBuf =2TSrc>pcc_eent( Wrie_EFow_Control_Mode_.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *****reak;
    }   *****cas S3177:        **********nBuf =2TSrc>pcc_eent( Rad_LBEFlush_TiO.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *********frameshtnnl(Ctx, tnBuf  TSrc>pcc_eent( Rad_LBEFlush_TiO.bst_Eefort_Ffush_Ttmeout_, 0);         *********nnonnsumd) = 24
        *       *nBuf = 24
        *       *nBuf - 24
    }   *****reak;
    }   *****cas S3178:        **********nBuf =2TSrc>pcc_eent( Wrie_EBEFlush_TiO.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *****reak;
    }   *****cas S3179:        **********nBuf =2TSrc>pcc_eent( Se_CShrt_FRange_ode_.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *****reak;
    }   *****cas S4097:        **********nBuf =2TSrc>pcc_eent( Rad_Locall_ersion_tInfo.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        **********nBuf =2TSrc>pcc_eent( Rad_Locall_ersion_tInfo.HC_CI_CVrsion_;         *********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *********frameshtnns(Ctx, tnBuf  TSrc>pcc_eent( Rad_Locall_ersion_tInfo.HC_CI_CReision_, 0);         *********nnonnsumd) = 2;
                 nBuf = 22;        *       *nBuf - 22;        **********nBuf =2TSrc>pcc_eent( Rad_Locall_ersion_tInfo.HC_PAL_ersion_;         *********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *********frameshtnns(Ctx, tnBuf  TSrc>pcc_eent( Rad_Locall_ersion_tInfo.HC_Manufac_Name, 0);         *********nnonnsumd) = 2;
                 nBuf = 22;        *       *nBuf - 22;        *********frameshtnns(Ctx, tnBuf  TSrc>pcc_eent( Rad_Locall_ersion_tInfo.HC_PAL_Sub_ersion_, 0);         *********nnonnsumd) = 2;
                 nBuf = 22;        *       *nBuf - 22;        *****reak;
    }   *****cas S4098:        **********nBuf =2TSrc>pcc_eent( Rad_Locall_Supprt_d_Emmds.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *********TAMP_PMEMCPY(Ctx, tnBuf  TSrc>pcc_eent( Rad_Locall_Supprt_d_Emmds.HC_Supprt_Emmds, 64);         *********nnonnsumd) = 264
        *       *nBuf = 264
        *       *nBuf - 264
    }   *****reak;
    }   *****cas S4101:        **********nBuf =2TSrc>pcc_eent( Rad_LBuffer_izeT.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *********frameshtnns(Ctx, tnBuf  TSrc>pcc_eent( Rad_LBuffer_izeT.HC_ACLEata_Backedt_Length, 0);         *********nnonnsumd) = 2;
                 nBuf = 22;        *       *nBuf - 22;        **********nBuf =2TSrc>pcc_eent( Rad_LBuffer_izeT.HC_SCOBackedt_Length
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *********frameshtnns(Ctx, tnBuf  TSrc>pcc_eent( Rad_LBuffer_izeT.HC_Totll_Num_ACLEackedts, 0);         *********nnonnsumd) = 2;
                 nBuf = 22;        *       *nBuf - 22;        *********frameshtnns(Ctx, tnBuf  TSrc>pcc_eent( Rad_LBuffer_izeT.HC_Totll_Num_SCOBackedts, 0);         *********nnonnsumd) = 2;
                 nBuf = 22;        *       *nBuf - 22;        *****reak;
    }   *****cas S4106:        **********nBuf =2TSrc>pcc_eent( Rad_Lata_BBlock_izeT.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *********frameshtnns(Ctx, tnBuf  TSrc>pcc_eent( Rad_Lata_BBlock_izeT.HC_Max_ACLEata_Backedt_Length, 0);         *********nnonnsumd) = 2;
                 nBuf = 22;        *       *nBuf - 22;        *********frameshtnns(Ctx, tnBuf  TSrc>pcc_eent( Rad_Lata_BBlock_izeT.HC_ata_BBlock_Length, 0);         *********nnonnsumd) = 2;
                 nBuf = 22;        *       *nBuf - 22;        *********frameshtnns(Ctx, tnBuf  TSrc>pcc_eent( Rad_Lata_BBlock_izeT.HC_Totll_Num_ata_BBlocks, 0);         *********nnonnsumd) = 2;
                 nBuf = 22;        *       *nBuf - 22;        *****reak;
    }   *****cas S5121:        **********nBuf =2TSrc>pcc_eent( Rad_LFaile_LCnntac_Emounter.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *********frameshtnns(Ctx, tnBuf  TSrc>pcc_eent( Rad_LFaile_LCnntac_Emounter.log_lnk_Chandle, 0);         *********nnonnsumd) = 2;
                 nBuf = 22;        *       *nBuf - 22;        *********frameshtnns(Ctx, tnBuf  TSrc>pcc_eent( Rad_LFaile_LCnntac_Emounter.faile_Lcnntac_Ecounter, 0);         *********nnonnsumd) = 2;
                 nBuf = 22;        *       *nBuf - 22;        *****reak;
    }   *****cas S5122:        **********nBuf =2TSrc>pcc_eent( Rasdt_Faile_LCnntac_Emounter.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *********frameshtnns(Ctx, tnBuf  TSrc>pcc_eent( Rasdt_Faile_LCnntac_Emounter.log_lnk_Chandle, 0);         *********nnonnsumd) = 2;
                 nBuf = 22;        *       *nBuf - 22;        *****reak;
    }   *****cas S5123:        **********nBuf =2TSrc>pcc_eent( Rad_Link_CQuality.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *********frameshtnns(Ctx, tnBuf  TSrc>pcc_eent( Rad_Link_CQuality.log_lnk_Chandle, 0);         *********nnonnsumd) = 2;
                 nBuf = 22;        *       *nBuf - 22;        **********nBuf =2TSrc>pcc_eent( Rad_Link_CQuality.lnk_Cquality
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *****reak;
    }   *****cas S5125:        **********nBuf =2TSrc>pcc_eent( Rad_LRSSI.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        **********nBuf =2TSrc>pcc_eent( Rad_LRSSI.phy_lnk_Chandle;        **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        **********nBuf =2TSrc>pcc_eent( Rad_LRSSI.rssi
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *****reak;
    }   *****cas S5129:        **********nBuf =2TSrc>pcc_eent( Rad_Locall_MP_PInfo.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        **********nBuf =2TSrc>pcc_eent( Rad_Locall_MP_PInfo.HC_AP_PUatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *********frameshtnnl(Ctx, tnBuf  TSrc>pcc_eent( Rad_Locall_MP_PInfo.HC_Totll_BW, 0);         *********nnonnsumd) = 24
        *       *nBuf = 24
        *       *nBuf - 24
    }   *********frameshtnnl(Ctx, tnBuf  TSrc>pcc_eent( Rad_Locall_MP_PInfo.HC_Max_Guarantee_LBW, 0);         *********nnonnsumd) = 24
        *       *nBuf = 24
        *       *nBuf - 24
    }   *********frameshtnnl(Ctx, tnBuf  TSrc>pcc_eent( Rad_Locall_MP_PInfo.HC_Min_Latency, 0);         *********nnonnsumd) = 24
        *       *nBuf = 24
        *       *nBuf - 24
    }   *********frameshtnnl(Ctx, tnBuf  TSrc>pcc_eent( Rad_Locall_MP_PInfo.HC_Max_PDU_izeT, 0);         *********nnonnsumd) = 24
        *       *nBuf = 24
        *       *nBuf - 24
    }   **********nBuf =2TSrc>pcc_eent( Rad_Locall_MP_PInfo.HC_ontrol_ler_Type;        **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *********frameshtnns(Ctx, tnBuf  TSrc>pcc_eent( Rad_Locall_MP_PInfo.HC_PAL_Capabilities, 0);         *********nnonnsumd) = 2;
                 nBuf = 22;        *       *nBuf - 22;        *********frameshtnns(Ctx, tnBuf  TSrc>pcc_eent( Rad_Locall_MP_PInfo.HC_AP_Pssoc_CLength, 0);         *********nnonnsumd) = 2;
                 nBuf = 22;        *       *nBuf - 22;        *********frameshtnnl(Ctx, tnBuf  TSrc>pcc_eent( Rad_Locall_MP_PInfo.HC_Max_lush_Timeout_, 0);         *********nnonnsumd) = 24
        *       *nBuf = 24
        *       *nBuf - 24
    }   *********frameshtnnl(Ctx, tnBuf  TSrc>pcc_eent( Rad_Locall_MP_PInfo.HC_BEFlush_Timeout_, 0);         *********nnonnsumd) = 24
        *       *nBuf = 24
        *       *nBuf - 24
    }   *****reak;
    }   *****cas S5130:        **********nBuf =2TSrc>pcc_eent( Rad_LRad_Locall_MP_Pssoc_.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        **********nBuf =2TSrc>pcc_eent( Rad_LRad_Locall_MP_Pssoc_.phy_lnk_Chandle;        **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *********frameshtnns(Ctx, tnBuf  TSrc>pcc_eent( Rad_LRad_Locall_MP_Pssoc_.remai_ing_length, 0);         *********nnonnsumd) = 2;
                 nBuf = 22;        *       *nBuf - 22;        *********TAMP_PMEMCPY(Ctx, tnBuf  &(}TSrc>pcc_eent( Rad_LRad_Locall_MP_Pssoc_.MP_Pasoc_Cfragmnt )
  TSrc>pcc_eent( Rad_LRad_Locall_MP_Pssoc_.remai_ing_length);         *********nnonnsumd) = 2TSrc>pcc_eent( Rad_LRad_Locall_MP_Pssoc_.remai_ing_length
                 nBuf = 2(}TSrc>pcc_eent( Rad_LRad_Locall_MP_Pssoc_.remai_ing_length );                *nBuf - 2(}TSrc>pcc_eent( Rad_LRad_Locall_MP_Pssoc_.remai_ing_length );             reak;
    }   *****cas S5131:        **********nBuf =2TSrc>pcc_eent( Wrie_ERemoe_EMP_Pssoc_.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        **********nBuf =2TSrc>pcc_eent( Wrie_ERemoe_EMP_Pssoc_.phy_lnk_Chandle;        **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *****reak;
    }   *****cas S6145:        **********nBuf =2TSrc>pcc_eent( Rad_LLoopbackMode_.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        **********nBuf =2TSrc>pcc_eent( Rad_LLoopbackMode_.loopbackMmde_
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *****reak;
    }   *****cas S6146:        **********nBuf =2TSrc>pcc_eent( Wrie_EocopbackMode_.tatus;
}       **********nnonnsumd) = 21
        *       *nBuf = 21;        *       *nBuf - 21;        *****reak;
    }   *}         reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        *pnlv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_Cmmmand_Cmmplete_Event( */

typedef v_U32_t (*pfnPackSTvHCI_Cmmmand_Cmmplete_Event(M)(poid *, tBtampTLVHCI_Cmmmand_Cmmplete_Event( *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_Cmmmand_Cmmplete_Event(  0x00484)

v_U32_t btampGackSTvHCI_Cmmmand_CUatus;Event((oid * pCtx,         **************************************BtampTLVHCI_Cmmmand_CUatus;Event( *pSrc         **************************************_U38t**pnBuf         **************************************_U32_t bnBuf         **************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B;
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_Cmmmand_CUatus;Event((Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  15, 0);         els S*nBuf =215
        *nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         *nBuf =2TSrc>ptatus;
}       **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        **nBuf =2TSrc>pnum_hci_cmmand_Cpckedts;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *frameshtnns(Ctx, tnBuf  TSrc>pcmmand_Copcode, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        *pnlv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_Cmmmand_CUatus;Event( */

typedef v_U32_t (*pfnPackSTvHCI_Cmmmand_CUatus;Event(M)(poid *, tBtampTLVHCI_Cmmmand_CUatus;Event( *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_Cmmmand_CUatus;Event(  0x00485)

v_U32_t btampGackSTvHCI_Cmeake_Eocical_Link_Cmmd(oid * pCtx,         *****************************************BtampTLVHCI_Cmeake_Eocical_Link_Cmmd *pSrc         ************************************** **_U38t**pnBuf         *****************************************_U32_t bnBuf         *****************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
      nonnsumd)OnEtroy= B*pnonnsumd);
    tatus = BtampGetPackedTlvHCI_Cmeake_Eocical_Link_Cmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  1080, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         *nBuf =2TSrc>pphy_lnk_Chandle;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *TAMP_PMEMCPY(Ctx, tnBuf  TSrc>ptx_fow_Ssec_  18);         *pnonnsumd) = 218
        *nBuf = 218;        *nBuf - 218;        *TAMP_PMEMCPY(Ctx, tnBuf  TSrc>prx_fow_Ssec_  18);         *pnonnsumd) = 218
        *nBuf = 218;        *nBuf - 218;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        *pnlv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_Cmeake_Eocical_Link_Cmmd */

typedef v_U32_t (*pfnPackSTvHCI_Cmeake_Eocical_Link_CmmdM)(poid *, tBtampTLVHCI_Cmeake_Eocical_Link_Cmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_Cmeake_Eocical_Link_Cmmd  0x00486)

v_U32_t btampGackSTvHCI_Cmeake_Ehysical_Link_Cmmd(oid * pCtx,         ******************************************BtampTLVHCI_Cmeake_Ehysical_Link_Cmmd *pSrc         ************************************** ***_U38t**pnBuf         ******************************************_U32_t bnBuf         ******************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_Cmeake_Ehysical_Link_Cmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  1077, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         *nBuf =2TSrc>pphy_lnk_Chandle;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        **nBuf =2TSrc>pkey_length;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        **nBuf =2TSrc>pkey_type;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *TAMP_PMEMCPY(Ctx, tnBuf  &(}TSrc>pkey_material=), TSrc>pkey_length);         *pnonnsumd) = 2TSrc>pkey_length;        *nBuf = 2(2TSrc>pkey_length );         nBuf - 2(2TSrc>pkey_length );         reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        *pnlv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_Cmeake_Ehysical_Link_Cmmd */

typedef v_U32_t (*pfnPackSTvHCI_Cmeake_Ehysical_Link_CmmdM)(poid *, tBtampTLVHCI_Cmeake_Ehysical_Link_Cmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_Cmeake_Ehysical_Link_Cmmd  0x00487)

v_U32_t btampGackSTvHCI_Cata_BBuffer_Overfow_Svent((oid * pCtx,         ********************************************BtampTLVHCI_Cata_BBuffer_Overfow_Svent( *pSrc         ************************************** *****_U38t**pnBuf         ********************************************_U32_t bnBuf         ********************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B;
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_Cata_BBuffer_Overfow_Svent((Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  26, 0);         els S*nBuf =226;         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         *nBuf =2TSrc>plnk_Ctype;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        *pnlv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_Cata_BBuffer_Overfow_Svent( */

typedef v_U32_t (*pfnPackSTvHCI_Cata_BBuffer_Overfow_Svent(M)(poid *, tBtampTLVHCI_Cata_BBuffer_Overfow_Svent( *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_Cata_BBuffer_Overfow_Svent(  0x00488)

v_U32_t btampGackSTvHCI_CaiscnnectiEocical_Link_Cmmd(oid * pCtx,         *********************************************BtampTLVHCI_CaiscnnectiEocical_Link_Cmmd *pSrc         ************************************** ******_U38t**pnBuf         *********************************************_U32_t bnBuf         *********************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CaiscnnectiEocical_Link_Cmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  1082, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         frameshtnns(Ctx, tnBuf  TSrc>plog_lnk_Chandle, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        *pnlv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CaiscnnectiEocical_Link_Cmmd */

typedef v_U32_t (*pfnPackSTvHCI_CaiscnnectiEocical_Link_CmmdM)(poid *, tBtampTLVHCI_CaiscnnectiEocical_Link_Cmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CaiscnnectiEocical_Link_Cmmd  0x00489)

v_U32_t btampGackSTvHCI_CaiscnnectiEocical_Link_Cmmplete_Event((oid * pCtx,         ********************************************************BtampTLVHCI_CaiscnnectiEocical_Link_Cmmplete_Event( *pSrc         ********************************************************_U38t**pnBuf         ********************************************************_U32_t bnBuf         ********************************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B;
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CaiscnnectiEocical_Link_Cmmplete_Event((Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  70, 0);         els S*nBuf =270;         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         *nBuf =2TSrc>ptatus;
}       **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *frameshtnns(Ctx, tnBuf  TSrc>plog_lnk_Chandle, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        **nBuf =2TSrc>peakson
}       **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        *pnlv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CaiscnnectiEocical_Link_Cmmplete_Event( */

typedef v_U32_t (*pfnPackSTvHCI_CaiscnnectiEocical_Link_Cmmplete_Event(M)(poid *, tBtampTLVHCI_CaiscnnectiEocical_Link_Cmmplete_Event( *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CaiscnnectiEocical_Link_Cmmplete_Event(  0x0048a)

v_U32_t btampGackSTvHCI_CaiscnnectiEhysical_Link_Cmmd(oid * pCtx,         **********************************************BtampTLVHCI_CaiscnnectiEhysical_Link_Cmmd *pSrc         ************************************** *******_U38t**pnBuf         **********************************************_U32_t bnBuf         **********************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CaiscnnectiEhysical_Link_Cmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  1079, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         *nBuf =2TSrc>pphy_lnk_Chandle;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        **nBuf =2TSrc>peakson
}       **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CaiscnnectiEhysical_Link_Cmmd */

typedef v_U32_t (*pfnPackSTvHCI_CaiscnnectiEhysical_Link_CmmdM)(poid *, tBtampTLVHCI_CaiscnnectiEhysical_Link_Cmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CaiscnnectiEhysical_Link_Cmmd  0x0048b)

v_U32_t btampGackSTvHCI_CaiscnnectiEhysical_Link_Cmmplete_Event((oid * pCtx,         ********************************************************tBtampTLVHCI_CaiscnnectiEhysical_Link_Cmmplete_Event( *pSrc         *********************************************************_U38t**pnBuf         *********************************************************_U32_t bnBuf         *********************************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B;
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CaiscnnectiEhysical_Link_Cmmplete_Event((Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  66, 0);         els S*nBuf =266;         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         *nBuf =2TSrc>ptatus;
}       **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        **nBuf =2TSrc>pphy_lnk_Chandle;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        **nBuf =2TSrc>peakson
}       **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CaiscnnectiEhysical_Link_Cmmplete_Event( */

typedef v_U32_t (*pfnPackSTvHCI_CaiscnnectiEhysical_Link_Cmmplete_Event(M)(poid *, tBtampTLVHCI_CaiscnnectiEhysical_Link_Cmmplete_Event( *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CaiscnnectiEhysical_Link_Cmmplete_Event(  0x0048c)

v_U32_t btampGackSTvHCI_CFow_CSec_MModifyCmmd(oid * pCtx,         **************************************BtampTLVHCI_CFow_CSec_MModifyCmmd *pSrc         **************************************_U38t**pnBuf         **************************************_U32_t bnBuf         **************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CFow_CSec_MModifyCmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  1084, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         frameshtnns(Ctx, tnBuf  TSrc>plog_lnk_Chandle, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        **nBuf =2TSrc>pbe_aggrEcounter
}       **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *TAMP_PMEMCPY(Ctx, tnBuf  TSrc>ptx_fow_Ssec_  18);         *pnonnsumd) = 218
        *nBuf = 218;        *nBuf - 218;        *TAMP_PMEMCPY(Ctx, tnBuf  TSrc>prx_fow_Ssec_  18);         *pnonnsumd) = 218
        *nBuf = 218;        *nBuf - 218;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CFow_CSec_MModifyCmmd */

typedef v_U32_t (*pfnPackSTvHCI_CFow_CSec_MModifyCmmdM)(poid *, tBtampTLVHCI_CFow_CSec_MModifyCmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CFow_CSec_MModifyCmmd  0x0048d)

v_U32_t btampGackSTvHCI_CFow_CSec_MModifyCmmplete_Event((oid * pCtx,         *************************************************BtampTLVHCI_CFow_CSec_MModifyCmmplete_Event( *pSrc         *************************************************_U38t**pnBuf         *************************************************_U32_t bnBuf         *************************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B;
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CFow_CSec_MModifyCmmplete_Event((Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  71, 0);         els S*nBuf =271
        *nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         *nBuf =2TSrc>ptatus;
}       **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *frameshtnns(Ctx, tnBuf  TSrc>plog_lnk_Chandle, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CFow_CSec_MModifyCmmplete_Event( */

typedef v_U32_t (*pfnPackSTvHCI_CFow_CSec_MModifyCmmplete_Event(M)(poid *, tBtampTLVHCI_CFow_CSec_MModifyCmmplete_Event( *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CFow_CSec_MModifyCmmplete_Event(  0x0048e)

v_U32_t btampGackSTvHCI_CFosh_Tmmd(oid * pCtx,         ***************************BtampTLVHCI_CFosh_Tmmd *pSrc         ***************************_U38t**pnBuf         ***************************_U32_t bnBuf         ***************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CFosh_Tmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  3080, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         frameshtnns(Ctx, tnBuf  TSrc>plog_lnk_Chandle, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CFosh_Tmmd */

typedef v_U32_t (*pfnPackSTvHCI_CFosh_TmmdM)(poid *, tBtampTLVHCI_CFosh_Tmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CFosh_Tmmd  0x0048f)

v_U32_t btampGackSTvHCI_CFosh_TOccurredEvent((oid * pCtx,         **************************************BtampTLVHCI_CFosh_TOccurredEvent( *pSrc         **************************************_U38t**pnBuf         **************************************_U32_t bnBuf         **************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B;
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CFosh_TOccurredEvent((Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  17, 0);         els S*nBuf =217;         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         frameshtnns(Ctx, tnBuf  TSrc>plog_lnk_Chandle, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CFosh_TOccurredEvent( */

typedef v_U32_t (*pfnPackSTvHCI_CFosh_TOccurredEvent(M)(poid *, tBtampTLVHCI_CFosh_TOccurredEvent( *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CFosh_TOccurredEvent(  0x00490)

v_U32_t btampGackSTvHCI_CNum_mmplete_d_Pkt;Event((oid * pCtx,         **************************************BtampTLVHCI_CNum_mmplete_d_Pkt;Event( *pSrc         **************************************_U38t**pnBuf         **************************************_U32_t bnBuf         **************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B;
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CNum_mmplete_d_Pkt;Event((Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW; //    hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  19, 0);         els S*nBuf =219;         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         *nBuf =2TSrc>pnum_handles;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *frameshtnns(Ctx, tnBuf  TSrc>pcmnn_handles[0], 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *frameshtnns(Ctx, tnBuf  TSrc>pnum_cmplete_d_pkt;[0], 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22; #f
 0        *// New        *frameshtnns(Ctx, tnBuf  0, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *frameshtnns(Ctx, tnBuf  0, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *frameshtnns(Ctx, tnBuf  0, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *frameshtnns(Ctx, tnBuf  0, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *frameshtnns(Ctx, tnBuf  0, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *frameshtnns(Ctx, tnBuf  0, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22; // nd bof new #endif //        reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CNum_mmplete_d_Pkt;Event( */

t_U32_t btampGackSTvHCI_CNum_mmplete_d_ata_BBlock;Event((oid * pCtx,         **************************************BtampTLVHCI_CNum_mmplete_d_ata_BBlock;Event( *pSrc         **************************************_U38t**pnBuf         **************************************_U32_t bnBuf         **************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B;
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CNum_mmplete_d_ata_BBlock;Event((Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW; //    hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  72, 0);         els S*nBuf =272
        *nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         frameshtnns(Ctx, tnBuf  TSrc>ptotal_num_dta_Bblock;, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        **nBuf =2TSrc>pnum_handles;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *frameshtnns(Ctx, tnBuf  TSrc>pcmnn_handles[0], 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *frameshtnns(Ctx, tnBuf  TSrc>pnum_cmplete_d_pkt;[0], 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *frameshtnns(Ctx, tnBuf  TSrc>pnum_cmplete_d_block;[0], 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22; #f
 0        *// New        *frameshtnns(Ctx, tnBuf  0, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *frameshtnns(Ctx, tnBuf  0, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *frameshtnns(Ctx, tnBuf  0, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *frameshtnns(Ctx, tnBuf  0, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *frameshtnns(Ctx, tnBuf  0, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *frameshtnns(Ctx, tnBuf  0, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22; // nd bof new #endif //        reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CNum_mmplete_d_ata_BBlock;Event( */

t//ypedef v_U32_t (*pfnPackSTvHCI_CNum_mmplete_d_Pkt;Event(M)(poid *, tBtampTLVHCI_CNum_mmplete_d_Pkt;Event( *,v_U38t*) v_U32_t  v_U32_t*);
#//define SigPackSTvHCI_CNum_mmplete_d_Pkt;Event(  0x00485)

v_U32_t btampGackSTvHCI_CGeneric_MP_Pink_CKey_NotificationEvent((oid * pCtx,         ********************************************************tBtampTLVHCI_CGeneric_MP_Pink_CKey_NotificationEvent( *pSrc         *********************************************************_U38t**pnBuf         *********************************************************_U32_t bnBuf         *********************************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B;
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CGeneric_MP_Pink_CKey_NotificationEvent((Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;    *nlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  62, 0);         els S*nBuf =262
        *nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         TAMP_PMEMCPY(Ctx, tnBuf  TSrc>pbd_addr  6);         *pnonnsumd) = 26;         nBuf = 26;        *nBuf - 26;         TAMP_PMEMCPY(Ctx, tnBuf  TSrc>pgeneric_mpG_lnk_Ckey, 32);         *pnonnsumd) = 232
        *nBuf = 232;        *nBuf - 232;        **nBuf =2TSrc>pkey_type;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CGeneric_MP_Pink_CKey_NotificationEvent( */

typedef v_U32_t (*pfnPackSTvHCI_CGeneric_MP_Pink_CKey_NotificationEvent(M)(poid *, tBtampTLVHCI_CGeneric_MP_Pink_CKey_NotificationEvent( *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CGeneric_MP_Pink_CKey_NotificationEvent(  0x00491)

v_U32_t btampGackSTvHCI_CHardware_ErrorEvent((oid * pCtx,         **************************************BtampTLVHCI_CHardware_ErrorEvent( *pSrc         **************************************_U38t**pnBuf         **************************************_U32_t bnBuf         **************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B;
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CHardware_ErrorEvent((Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;    *nlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  16, 0);         els S*nBuf =216;         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         *nBuf =2TSrc>phardware_code;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CHardware_ErrorEvent( */

typedef v_U32_t (*pfnPackSTvHCI_CHardware_ErrorEvent(M)(poid *, tBtampTLVHCI_CHardware_ErrorEvent( *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CHardware_ErrorEvent(  0x00492)

v_U32_t btampGackSTvHCI_Cocical_Link_CmancelCmmd(oid * pCtx,         *****************************************BtampTLVHCI_Cocical_Link_CmancelCmmd *pSrc         *****************************************_U38t**pnBuf         *****************************************_U32_t bnBuf         *****************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_Cocical_Link_CmancelCmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;    *nlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  1083, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         *nBuf =2TSrc>pphy_lnk_Chandle;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        **nBuf =2TSrc>ptx_fow_Ssec__id;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_Cocical_Link_CmancelCmmd */

typedef v_U32_t (*pfnPackSTvHCI_Cocical_Link_CmancelCmmdM)(poid *, tBtampTLVHCI_Cocical_Link_CmancelCmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_Cocical_Link_CmancelCmmd  0x00493)

v_U32_t btampGackSTvHCI_Cocical_Link_Cmmplete_Event((oid * pCtx,         *********************************************BtampTLVHCI_Cocical_Link_Cmmplete_Event( *pSrc         *********************************************_U38t**pnBuf         *********************************************_U32_t bnBuf         *********************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B;
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_Cocical_Link_Cmmplete_Event((Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  69, 0);         els S*nBuf =269;         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         *nBuf =2TSrc>ptatus;
}       **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *frameshtnns(Ctx, tnBuf  TSrc>plog_lnk_Chandle, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        **nBuf =2TSrc>pphy_lnk_Chandle;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        **nBuf =2TSrc>pfow_Ssec__id;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_Cocical_Link_Cmmplete_Event( */

typedef v_U32_t (*pfnPackSTvHCI_Cocical_Link_Cmmplete_Event(M)(poid *, tBtampTLVHCI_Cocical_Link_Cmmplete_Event( *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_Cocical_Link_Cmmplete_Event(  0x00494)

v_U32_t btampGackSTvHCI_CocopbckSCmmpmandEvent((oid * pCtx,         ****************************************BtampTLVHCI_CocopbckSCmmpmandEvent( *pSrc         ****************************************_U38t**pnBuf         ****************************************_U32_t bnBuf         ****************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B;
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CocopbckSCmmpmandEvent((Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  25, 0);         els S*nBuf =225;         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         TAMP_PMEMCPY(Ctx, tnBuf  TSrc>phci_cmpmandEpcked  v64);         *pnonnsumd) = 264;        *nBuf = 264;        *nBuf - 264;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CocopbckSCmmpmandEvent( */

typedef v_U32_t (*pfnPackSTvHCI_CocopbckSCmmpmandEvent(M)(poid *, tBtampTLVHCI_CocopbckSCmmpmandEvent( *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CocopbckSCmmpmandEvent(  0x00495)

v_U32_t btampGackSTvHCI_Chysical_Link_Cmmplete_Event((oid * pCtx,         **********************************************BtampTLVHCI_Chysical_Link_Cmmplete_Event( *pSrc         **********************************************_U38t**pnBuf         **********************************************_U32_t bnBuf         **********************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B;
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_Chysical_Link_Cmmplete_Event((Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  64, 0);         els S*nBuf =264;        *nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         *nBuf =2TSrc>ptatus;
}       **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        **nBuf =2TSrc>pphy_lnk_Chandle;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_Chysical_Link_Cmmplete_Event( */

typedef v_U32_t (*pfnPackSTvHCI_Chysical_Link_Cmmplete_Event(M)(poid *, tBtampTLVHCI_Chysical_Link_Cmmplete_Event( *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_Chysical_Link_Cmmplete_Event(  0x00496)

v_U32_t btampGackSTvHCI_Chysical_Link_CLoss_WarningEvent((oid * pCtx,         **************************************************BtampTLVHCI_Chysical_Link_CLoss_WarningEvent( *pSrc         **************************************************_U38t**pnBuf         **************************************************_U32_t bnBuf         **************************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B;
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_Chysical_Link_CLoss_WarningEvent((Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  67, 0);         els S*nBuf =267;         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         *nBuf =2TSrc>pphy_lnk_Chandle;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        **nBuf =2TSrc>peakson
}       **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_Chysical_Link_CLoss_WarningEvent( */

typedef v_U32_t (*pfnPackSTvHCI_Chysical_Link_CLoss_WarningEvent(M)(poid *, tBtampTLVHCI_Chysical_Link_CLoss_WarningEvent( *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_Chysical_Link_CLoss_WarningEvent(  0x00497)

v_U32_t btampGackSTvHCI_Chysical_Link_CRecoveryEvent((oid * pCtx,         **********************************************BtampTLVHCI_Chysical_Link_CRecoveryEvent( *pSrc         **********************************************_U38t**pnBuf         **********************************************_U32_t bnBuf         **********************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B;
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_Chysical_Link_CRecoveryEvent((Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  68, 0);         els S*nBuf =268
        *nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         *nBuf =2TSrc>pphy_lnk_Chandle;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_Chysical_Link_CRecoveryEvent( */

typedef v_U32_t (*pfnPackSTvHCI_Chysical_Link_CRecoveryEvent(M)(poid *, tBtampTLVHCI_Chysical_Link_CRecoveryEvent( *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_Chysical_Link_CRecoveryEvent(  0x00498)

v_U32_t btampGackSTvHCI_CQos_ViolationEvent((oid * pCtx,         *************************************BtampTLVHCI_CQos_ViolationEvent( *pSrc         *************************************_U38t**pnBuf         *************************************_U32_t bnBuf         *************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B;
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CQos_ViolationEvent((Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  30, 0);         els S*nBuf =230
        *nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         frameshtnns(Ctx, tnBuf  TSrc>plog_lnk_Chandle, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CQos_ViolationEvent( */

typedef v_U32_t (*pfnPackSTvHCI_CQos_ViolationEvent(M)(poid *, tBtampTLVHCI_CQos_ViolationEvent( *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CQos_ViolationEvent(  0x00499)

v_U32_t btampGackSTvHCI_CRead_Best_EffortCFosh_TTimeoutCmmd(oid * pCtx,         ****************************************************BtampTLVHCI_CRead_Best_EffortCFosh_TTimeoutCmmd *pSrc         ****************************************************_U38t**pnBuf         ****************************************************_U32_t bnBuf         ****************************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CRead_Best_EffortCFosh_TTimeoutCmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  3177, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         frameshtnns(Ctx, tnBuf  TSrc>plog_lnk_Chandle, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CRead_Best_EffortCFosh_TTimeoutCmmd */

typedef v_U32_t (*pfnPackSTvHCI_CRead_Best_EffortCFosh_TTimeoutCmmdM)(poid *, tBtampTLVHCI_CRead_Best_EffortCFosh_TTimeoutCmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CRead_Best_EffortCFosh_TTimeoutCmmd  0x0049a)

v_U32_t btampGackSTvHCI_CRead_Buffer_SizeCmmd(oid * pCtx,         **************************************BtampTLVHCI_CRead_Buffer_SizeCmmd *pSrc         **************************************_U38t**pnBuf         **************************************_U32_t bnBuf         **************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CRead_Buffer_SizeCmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  4101, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CRead_Buffer_SizeCmmd */

typedef v_U32_t (*pfnPackSTvHCI_CRead_Buffer_SizeCmmdM)(poid *, tBtampTLVHCI_CRead_Buffer_SizeCmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CRead_Buffer_SizeCmmd  0x0049b)

v_U32_t btampGackSTvHCI_CRead_onnnectionEAcceptTTimeoutCmmd(oid * pCtx,         ****************************************************BtampTLVHCI_CRead_onnnectionEAcceptTTimeoutCmmd *pSrc         ****************************************************_U38t**pnBuf         ****************************************************_U32_t bnBuf         ****************************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CRead_onnnectionEAcceptTTimeoutCmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  3093, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CRead_onnnectionEAcceptTTimeoutCmmd */

typedef v_U32_t (*pfnPackSTvHCI_CRead_onnnectionEAcceptTTimeoutCmmdM)(poid *, tBtampTLVHCI_CRead_onnnectionEAcceptTTimeoutCmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CRead_onnnectionEAcceptTTimeoutCmmd  0x0049c)

v_U32_t btampGackSTvHCI_CRead_ata_BBlock_SizeCmmd(oid * pCtx,         ******************************************BtampTLVHCI_CRead_ata_BBlock_SizeCmmd *pSrc         ******************************************_U38t**pnBuf         ******************************************_U32_t bnBuf         ******************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CRead_ata_BBlock_SizeCmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  4106, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CRead_ata_BBlock_SizeCmmd */

typedef v_U32_t (*pfnPackSTvHCI_CRead_ata_BBlock_SizeCmmdM)(poid *, tBtampTLVHCI_CRead_ata_BBlock_SizeCmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CRead_ata_BBlock_SizeCmmd  0x0049d)

v_U32_t btampGackSTvHCI_CRead_Fale d_onntactCmounter_mmd(oid * pCtx,         *************************************************BtampTLVHCI_CRead_Fale d_onntactCmounter_mmd *pSrc         *************************************************_U38t**pnBuf         *************************************************_U32_t bnBuf         *************************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CRead_Fale d_onntactCmounter_mmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  5121, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         frameshtnns(Ctx, tnBuf  TSrc>plog_lnk_Chandle, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CRead_Fale d_onntactCmounter_mmd */

typedef v_U32_t (*pfnPackSTvHCI_CRead_Fale d_onntactCmounter_mmdM)(poid *, tBtampTLVHCI_CRead_Fale d_onntactCmounter_mmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CRead_Fale d_onntactCmounter_mmd  0x0049e)

v_U32_t btampGackSTvHCI_CRead_Fow_Sonntrol_ModeCmmd(oid * pCtx,         ********************************************BtampTLVHCI_CRead_Fow_Sonntrol_ModeCmmd *pSrc         ********************************************_U38t**pnBuf         ********************************************_U32_t bnBuf         ********************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CRead_Fow_Sonntrol_ModeCmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  3174, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         reak;
    }
    }     f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CRead_Fow_Sonntrol_ModeCmmd */

typedef v_U32_t (*pfnPackSTvHCI_CRead_Fow_Sonntrol_ModeCmmdM)(poid *, tBtampTLVHCI_CRead_Fow_Sonntrol_ModeCmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CRead_Fow_Sonntrol_ModeCmmd  0x0049f)

v_U32_t btampGackSTvHCI_CRead_ink_CQualityCmmd(oid * pCtx,         ***************************************BtampTLVHCI_CRead_ink_CQualityCmmd *pSrc         ***************************************_U38t**pnBuf         ***************************************_U32_t bnBuf         ***************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CRead_ink_CQualityCmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  5123, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         frameshtnns(Ctx, tnBuf  TSrc>plog_lnk_Chandle, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *reak;
    }
    }     f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CRead_ink_CQualityCmmd */

typedef v_U32_t (*pfnPackSTvHCI_CRead_ink_CQualityCmmdM)(poid *, tBtampTLVHCI_CRead_ink_CQualityCmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CRead_ink_CQualityCmmd  0x004a0)

v_U32_t btampGackSTvHCI_CRead_ink_CSupervisionETimeoutCmmd(oid * pCtx,         ***************************************************BtampTLVHCI_CRead_ink_CSupervisionETimeoutCmmd *pSrc         ***************************************************_U38t**pnBuf         ***************************************************_U32_t bnBuf         ***************************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    {
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CRead_ink_CSupervisionETimeoutCmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  3126, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         frameshtnns(Ctx, tnBuf  TSrc>plog_lnk_Chandle, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CRead_ink_CSupervisionETimeoutCmmd */

typedef v_U32_t (*pfnPackSTvHCI_CRead_ink_CSupervisionETimeoutCmmdM)(poid *, tBtampTLVHCI_CRead_ink_CSupervisionETimeoutCmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CRead_ink_CSupervisionETimeoutCmmd  0x004a1)

v_U32_t btampGackSTvHCI_CRead_ioal_LMP_PAssocCmmd(oid * pCtx,         ******************************************BtampTLVHCI_CRead_ioal_LMP_PAssocCmmd *pSrc         ******************************************_U38t**pnBuf         ******************************************_U32_t bnBuf         ******************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    *
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CRead_ioal_LMP_PAssocCmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  5130, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         *nBuf =2TSrc>pphy_lnk_Chandle;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *frameshtnns(Ctx, tnBuf  TSrc>plength_so_far, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *frameshtnns(Ctx, tnBuf  TSrc>pmax_remote_mpG_assocClength, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CRead_ioal_LMP_PAssocCmmd */

typedef v_U32_t (*pfnPackSTvHCI_CRead_ioal_LMP_PAssocCmmdM)(poid *, tBtampTLVHCI_CRead_ioal_LMP_PAssocCmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CRead_ioal_LMP_PAssocCmmd  0x004a2)

v_U32_t btampGackSTvHCI_CRead_ioal_LMP_PInformationEmmd(oid * pCtx,         ************************************************BtampTLVHCI_CRead_ioal_LMP_PInformationEmmd *pSrc         ************************************************_U38t**pnBuf         ************************************************_U32_t bnBuf         ************************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    *
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CRead_ioal_LMP_PInformationEmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  5129, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CRead_ioal_LMP_PInformationEmmd */

typedef v_U32_t (*pfnPackSTvHCI_CRead_ioal_LMP_PInformationEmmdM)(poid *, tBtampTLVHCI_CRead_ioal_LMP_PInformationEmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CRead_ioal_LMP_PInformationEmmd  0x004a3)

v_U32_t btampGackSTvHCI_CRead_ioal_LSupport d_omdsEmmd(oid * pCtx,         ***********************************************BtampTLVHCI_CRead_ioal_LSupport d_omdsEmmd *pSrc         ***********************************************_U38t**pnBuf         ***********************************************_U32_t bnBuf         ***********************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    *
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CRead_ioal_LSupport d_omdsEmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  4098, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CRead_ioal_LSupport d_omdsEmmd */

typedef v_U32_t (*pfnPackSTvHCI_CRead_ioal_LSupport d_omdsEmmdM)(poid *, tBtampTLVHCI_CRead_ioal_LSupport d_omdsEmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CRead_ioal_LSupport d_omdsEmmd  0x004a4)

v_U32_t btampGackSTvHCI_CRead_ioal_LVersionEInfoEmmd(oid * pCtx,         *********************************************BtampTLVHCI_CRead_ioal_LVersionEInfoEmmd *pSrc         *********************************************_U38t**pnBuf         *********************************************_U32_t bnBuf         *********************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    *
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CRead_ioal_LVersionEInfoEmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  4097, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
     {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CRead_ioal_LVersionEInfoEmmd */

typedef v_U32_t (*pfnPackSTvHCI_CRead_ioal_LVersionEInfoEmmdM)(poid *, tBtampTLVHCI_CRead_ioal_LVersionEInfoEmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CRead_ioal_LVersionEInfoEmmd  0x004a5)

v_U32_t btampGackSTvHCI_CRead_ioaltionEata_Bmmd(oid * pCtx,         ****************************************BtampTLVHCI_CRead_ioaltionEata_Bmmd *pSrc         ****************************************_U38t**pnBuf         ****************************************_U32_t bnBuf         ****************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    *
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CRead_ioaltionEata_Bmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  3172, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CRead_ioaltionEata_Bmmd */

typedef v_U32_t (*pfnPackSTvHCI_CRead_ioaltionEata_BmmdM)(poid *, tBtampTLVHCI_CRead_ioaltionEata_Bmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CRead_ioaltionEata_Bmmd  0x004a6)

v_U32_t btampGackSTvHCI_CRead_iogcal_Link_CAcceptTTimeoutCmmd(oid * pCtx,         ******************************************************BtampTLVHCI_CRead_iogcal_Link_CAcceptTTimeoutCmmd *pSrc         ******************************************************_U38t**pnBuf         ******************************************************_U32_t bnBuf         ******************************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    *
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CRead_iogcal_Link_CAcceptTTimeoutCmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  3169, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CRead_iogcal_Link_CAcceptTTimeoutCmmd */

typedef v_U32_t (*pfnPackSTvHCI_CRead_iogcal_Link_CAcceptTTimeoutCmmdM)(poid *, tBtampTLVHCI_CRead_iogcal_Link_CAcceptTTimeoutCmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CRead_iogcal_Link_CAcceptTTimeoutCmmd  0x004a7)

v_U32_t btampGackSTvHCI_CRead_ioopbckS_ModeCmmd(oid * pCtx,         ****************************************BtampTLVHCI_CRead_ioopbckS_ModeCmmd *pSrc         ****************************************_U38t**pnBuf         ****************************************_U32_t bnBuf         ****************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    *
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CRead_ioopbckS_ModeCmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  6145, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CRead_ioopbckS_ModeCmmd */

typedef v_U32_t (*pfnPackSTvHCI_CRead_ioopbckS_ModeCmmdM)(poid *, tBtampTLVHCI_CRead_ioopbckS_ModeCmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CRead_ioopbckS_ModeCmmd  0x004a8)

v_U32_t btampGackSTvHCI_CRead_RSSICmmd(oid * pCtx,         *******************************BtampTLVHCI_CRead_RSSICmmd *pSrc         *******************************_U38t**pnBuf         *******************************_U32_t bnBuf         *******************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    *
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CRead_RSSICmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  5125, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         frameshtnns(Ctx, tnBuf  TSrc>plog_lnk_Chandle, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CRead_RSSICmmd */

typedef v_U32_t (*pfnPackSTvHCI_CRead_RSSICmmdM)(poid *, tBtampTLVHCI_CRead_RSSICmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CRead_RSSICmmd  0x004a9)

v_U32_t btampGackSTvHCI_CResetCmmd(oid * pCtx,         ***************************BtampTLVHCI_CResetCmmd *pSrc         ***************************_U38t**pnBuf         ***************************_U32_t bnBuf         ***************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    *
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CResetCmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  3075, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CResetCmmd */

typedef v_U32_t (*pfnPackSTvHCI_CResetCmmdM)(poid *, tBtampTLVHCI_CResetCmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CResetCmmd  0x004aa)

v_U32_t btampGackSTvHCI_CResetCFale d_onntactCmounter_mmd(oid * pCtx,         *************************************************tBtampTLVHCI_CResetCFale d_onntactCmounter_mmd *pSrc         **************************************************_U38t**pnBuf         **************************************************_U32_t bnBuf         **************************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    *
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CResetCFale d_onntactCmounter_mmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  5122, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         frameshtnns(Ctx, tnBuf  TSrc>plog_lnk_Chandle, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CResetCFale d_onntactCmounter_mmd */

typedef v_U32_t (*pfnPackSTvHCI_CResetCFale d_onntactCmounter_mmdM)(poid *, tBtampTLVHCI_CResetCFale d_onntactCmounter_mmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CResetCFale d_onntactCmounter_mmd  0x004ab)

v_U32_t btampGackSTvHCI_CSetCEvnt _Mask_mmd(oid * pCtx,         ************************************BtampTLVHCI_CSetCEvnt _Mask_mmd *pSrc         ************************************_U38t**pnBuf         ************************************_U32_t bnBuf         ************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    *
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CSetCEvnt _Mask_mmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  3077, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         TAMP_PMEMCPY(Ctx, tnBuf  TSrc>pevnt _mask, 8);         *pnonnsumd) = 28;        *nBuf = 28;        *nBuf - 28;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CSetCEvnt _Mask_mmd */

typedef v_U32_t (*pfnPackSTvHCI_CSetCEvnt _Mask_mmdM)(poid *, tBtampTLVHCI_CSetCEvnt _Mask_mmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CSetCEvnt _Mask_mmd  0x004ac)

v_U32_t btampGackSTvHCI_CSetCEvnt _Mask_Page_2_mmd(oid * pCtx,         *******************************************BtampTLVHCI_CSetCEvnt _Mask_Page_2_mmd *pSrc         *******************************************_U38t**pnBuf         *******************************************_U32_t bnBuf         *******************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    *
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CSetCEvnt _Mask_Page_2_mmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  3171, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         TAMP_PMEMCPY(Ctx, tnBuf  TSrc>pevnt _mask_page_2, 8);         *pnonnsumd) = 28;        *nBuf = 28;        *nBuf - 28;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CSetCEvnt _Mask_Page_2_mmd */

typedef v_U32_t (*pfnPackSTvHCI_CSetCEvnt _Mask_Page_2_mmdM)(poid *, tBtampTLVHCI_CSetCEvnt _Mask_Page_2_mmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CSetCEvnt _Mask_Page_2_mmd  0x004ad)

v_U32_t btampGackSTvHCI_CSetCShort_Range_ModeCmmd(oid * pCtx,         ******************************************BtampTLVHCI_CSetCShort_Range_ModeCmmd *pSrc         ******************************************_U38t**pnBuf         ******************************************_U32_t bnBuf         ******************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    *
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CSetCShort_Range_ModeCmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  3179, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         *nBuf =2TSrc>pphy_lnk_Chandle;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        **nBuf =2TSrc>pshort_range_mode;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CSetCShort_Range_ModeCmmd */

typedef v_U32_t (*pfnPackSTvHCI_CSetCShort_Range_ModeCmmdM)(poid *, tBtampTLVHCI_CSetCShort_Range_ModeCmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CSetCShort_Range_ModeCmmd  0x004ae)

v_U32_t btampGackSTvHCI_CShort_Range_ModeCmhange_CompleteCEvnt (oid * pCtx,         ********************************************************BtampTLVHCI_CShort_Range_ModeCmhange_CompleteCEvnt  *pSrc         ********************************************************_U38t**pnBuf         ********************************************************_U32_t bnBuf         ********************************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B1
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    *
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CShort_Range_ModeCmhange_CompleteCEvnt (Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  76, 0);         els S*nBuf =276;         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         *nBuf =2TSrc>ptatus;
}        *nnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        **nBuf =2TSrc>pphy_lnk_Chandle;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        **nBuf =2TSrc>pshort_range_mode;        **pnonnsumd) = 21
        *nBuf = 21;        *nBuf - 21;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CShort_Range_ModeCmhange_CompleteCEvnt  */

typedef v_U32_t (*pfnPackSTvHCI_CShort_Range_ModeCmhange_CompleteCEvnt M)(poid *, tBtampTLVHCI_CShort_Range_ModeCmhange_CompleteCEvnt  *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CShort_Range_ModeCmhange_CompleteCEvnt   0x004af)

v_U32_t btampGackSTvHCI_CWriteCBest_Effort_FlushTTimeoutCmmd(oid * pCtx,         *****************************************************BtampTLVHCI_CWriteCBest_Effort_FlushTTimeoutCmmd *pSrc         *****************************************************_U38t**pnBuf         *****************************************************_U32_t bnBuf         *****************************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    *
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad input" );         eturn sTAMP_PBADPINPUT_BUFFER;     
     nonnsumd)OnEtroy= B*pnonnsumd);
    wtatus = BtampGetPackedTlvHCI_CWriteCBest_Effort_FlushTTimeoutCmmd(Ctx, BpSrc  &Needed)
;     f
 (}!sTAMP_PUCCESEDED(wtatus =) )return status;
}    needed += 2tType++ tLen;     f
 (}needed +>bnBuf )return sTAMP_PBUFFER_OVERFLOW;     Tlv-Len= BnBuf;     hile ( pTSrc>present )
    {
        *if(ptType+  B2) frameshtnns(pCtx, tnBuf  3178, 0);         nBuf = 2tType;bnBuf - 2tType;b*pnonnsumd) = 2tType;        *nlv-Len= BnBuf;        *nBuf = 2tLen;bnBuf - 2tLen;b*pnonnsumd) = 2tLen;         frameshtnns(Ctx, tnBuf  TSrc>plog_lnk_Chandle, 0);         *pnonnsumd) = 22
        *nBuf = 22;        *nBuf - 22;        *frameshtnnl(Ctx, tnBuf  TSrc>pbest_effort_flushTtimeout, 0);         *pnonnsumd) = 24
        *nBuf = 24;        *nBuf - 24;        *reak;
    }
      f
 (nlv-Len=&& tLen=  B2)    {
        *frameshtnns(pCtx, tnlv-Len, *pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen, 0);     } els Sif(NULL ! 2Tlv-Len
    {
        **plv-Len= B(_U38t*)(*pnonnsumd) - nonnsumd)OnEtroy=-ptType+- tLen);     }    return status;
} /* End btampGackSTvHCI_CWriteCBest_Effort_FlushTTimeoutCmmd */

typedef v_U32_t (*pfnPackSTvHCI_CWriteCBest_Effort_FlushTTimeoutCmmdM)(poid *, tBtampTLVHCI_CWriteCBest_Effort_FlushTTimeoutCmmd *,v_U38t*) v_U32_t  v_U32_t*);
#define SigPackSTvHCI_CWriteCBest_Effort_FlushTTimeoutCmmd  0x004b0)

v_U32_t btampGackSTvHCI_CWriteConnnectionEAcceptTTimeoutCmmd(oid * pCtx,         *****************************************************BtampTLVHCI_CWriteConnnectionEAcceptTTimeoutCmmd *pSrc         *****************************************************_U38t**pnBuf         *****************************************************_U32_t bnBuf         *****************************************************_U32_t b*pnonnsumd)
{
    v_U38t*)}Tlv-Len= B0
    }_U32_t bnonnsumd)OnEtroy
    }_U32_t btatus = BTAMP_PARSE_SUCCESS;
    (_U32_t bneeded + B0U
    }_U32_t btType+ B0U
    }_U32_t btLen= B0U
    }tType+ B2
     tLen= B1;        *// sanity checking
    if(pCtx, == NULL || pSrc == NULL ||        *nBuf == NULL || pnonnsumd) == NULL
    *
        *VOS_TRACE( VOS_MODULE_ID_BAP, VOS_TRACE_LEVEL_ERROR, "bad i